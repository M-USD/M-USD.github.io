<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üì±M-USD</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Chart.js for crypto price charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --primary: #00a651;
            --secondary: #00a651;
            --dark: #333;
            --light: #f5f5f5;
            --danger: #e74c3c;
            --success: #2ecc71;
            --warning: #f39c12;
            --info: #3498db;
        }

        body {
            background-color: #f0f2f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 400px;
            margin: 0 auto;
            padding: 20px;
        }

        .app-header {
            background: linear-gradient(to right, var(--primary), var(--secondary));
            color: white;
            padding: 15px 0;
            text-align: center;
            border-radius: 0 0 20px 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .app-header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .btn {
            display: block;
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            margin: 10px 0;
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
        }

        .btn-secondary {
            background-color: var(--secondary);
            color: white;
        }

        .btn-danger {
            background-color: var(--danger);
            color: white;
        }

        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .form-control {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
        }

        .hidden {
            display: none !important;
        }

        .nav-tabs {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }

        .nav-tab {
            flex: 1;
            text-align: center;
            padding: 10px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }

        .nav-tab.active {
            border-bottom: 3px solid var(--primary);
            color: var(--primary);
            font-weight: 600;
        }

        .balance-card {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            text-align: center;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
        }

        .balance-amount {
            font-size: 32px;
            font-weight: 700;
            margin: 10px 0;
        }

        .transaction-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #eee;
            background: white;
            margin-bottom: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .transaction-details {
            flex: 1;
        }

        .transaction-type {
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .transaction-date {
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
        }

        .transaction-fee {
            font-size: 12px;
            color: #f39c12;
        }

        .transaction-method {
            font-size: 12px;
            color: #3498db;
            margin-top: 4px;
        }

        .transaction-amount {
            font-weight: 700;
            font-size: 16px;
        }

        .transaction-positive {
            color: #27ae60;
        }

        .transaction-negative {
            color: #e74c3c;
        }

        .menu-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .menu-item {
            background: white;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .menu-item:hover {
            transform: translateY(-5px);
        }

        .menu-icon {
            font-size: 24px;
            margin-bottom: 10px;
            color: var(--primary);
        }

        /* Updated Admin Panel Styles */
        .admin-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }

        .admin-layout {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        @media (min-width: 768px) {
            .admin-layout {
                flex-direction: row;
            }
        }

        .admin-section {
            flex: 1;
            margin-bottom: 20px;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .admin-section h3 {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--primary);
            color: var(--primary);
        }

        .user-item, .transaction-admin-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #eee;
            background: white;
            margin-bottom: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .user-info {
            flex: 1;
        }

        .user-phone {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .user-balance {
            color: #333;
            margin-bottom: 2px;
        }

        .user-registered {
            font-size: 12px;
            color: #666;
        }

        .user-controls {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        .user-actions {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .action-btn {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .action-btn.suspend {
            background-color: var(--warning);
            color: white;
        }

        .action-btn.block {
            background-color: var(--danger);
            color: white;
        }

        .action-btn.recover {
            background-color: var(--info);
            color: white;
        }

        .action-btn.deduct {
            background-color: var(--danger);
            color: white;
        }

        .status-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-active {
            background-color: var(--success);
            color: white;
        }

        .status-suspended {
            background-color: var(--warning);
            color: white;
        }

        .status-blocked {
            background-color: var(--danger);
            color: white;
        }

        .status-pending {
            background-color: var(--warning);
            color: white;
        }

        .status-rejected {
            background-color: var(--danger);
            color: white;
        }

        .status-completed {
            background-color: var(--success);
            color: white;
        }

        /* Deduction Modal Styles */
        .deduction-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .deduction-modal-content {
            background: white;
            border-radius: 12px;
            max-width: 400px;
            width: 90%;
            padding: 20px;
        }

        .deduction-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .deduction-modal-header h2 {
            margin: 0;
            color: var(--primary);
        }

        .close-deduction-modal {
            font-size: 24px;
            cursor: pointer;
            color: #666;
        }

        .deduction-user-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .deduction-user-info p {
            margin: 5px 0;
        }

        .deduction-form-group {
            margin-bottom: 15px;
        }

        .deduction-form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .deduction-form-control {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
        }

        .deduction-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .btn-deduct {
            background-color: var(--danger);
            color: white;
        }

        .btn-cancel {
            background-color: #6c757d;
            color: white;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            z-index: 1000;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .notification.success {
            background-color: var(--success);
        }

        .notification.error {
            background-color: var(--danger);
        }

        .notification.info {
            background-color: var(--info);
        }

        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .logo-icon {
            font-size: 28px;
        }

        .footer {
            text-align: center;
            margin-top: 30px;
            color: #777;
            font-size: 14px;
        }

        .loading {
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .no-transactions, .no-users {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }

        .transaction-info {
            flex: 1;
        }

        .transaction-parties {
            margin-bottom: 4px;
            font-weight: 500;
        }

        .transaction-amounts {
            text-align: right;
        }

        /* Crypto Trading Styles */
        .portfolio-summary {
            margin-bottom: 20px;
        }

        .portfolio-card {
            background: linear-gradient(135deg, #27ae60 0%, #27ae60 100%);
            color: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .portfolio-card h3 {
            margin-bottom: 15px;
            font-size: 18px;
        }

        .portfolio-balance {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .total-value {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 20px;
            font-weight: 700;
        }

        .breakdown {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .breakdown-item {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
        }

        .crypto-holdings, .crypto-market {
            margin-bottom: 20px;
        }

        .crypto-holdings h3, .crypto-market h3 {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            color: var(--primary);
        }

        .search-bar {
            margin-bottom: 15px;
        }

        .crypto-item, .holding-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #eee;
            background: white;
            margin-bottom: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .crypto-info, .holding-info {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }

        .crypto-icon, .holding-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f0f2f5;
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }

        .crypto-details, .holding-details {
            flex: 1;
        }

        .crypto-name, .holding-name {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .crypto-symbol, .holding-symbol {
            font-size: 12px;
            color: #666;
        }

        .crypto-price, .holding-quantity {
            text-align: right;
            margin-right: 10px;
        }

        .crypto-current, .holding-amount {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .crypto-change, .holding-change {
            font-size: 12px;
        }

        .positive {
            color: var(--success);
        }

        .negative {
            color: var(--danger);
        }

        .holding-value {
            font-size: 12px;
            color: #666;
        }

        .crypto-actions {
            display: flex;
            gap: 5px;
        }

        .btn-trade {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-trade[data-action="buy"] {
            background-color: var(--success);
            color: white;
        }

        .btn-trade[data-action="sell"] {
            background-color: var(--danger);
            color: white;
        }

        .no-crypto, .no-holdings {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }

        /* Crypto Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            max-width: 400px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #eee;
        }

        .modal-header h2 {
            margin: 0;
            color: var(--primary);
        }

        .close-modal {
            font-size: 24px;
            cursor: pointer;
            color: #666;
        }

        .modal-body {
            padding: 20px;
        }

        .crypto-info {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .crypto-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #e9ecef;
            font-size: 24px;
            font-weight: bold;
        }

        .crypto-details h3 {
            margin: 0 0 5px 0;
        }

        .crypto-details p {
            margin: 0;
            color: #666;
        }

        .trade-tabs {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }

        .trade-tab {
            flex: 1;
            text-align: center;
            padding: 10px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }

        .trade-tab.active {
            border-bottom: 3px solid var(--primary);
            color: var(--primary);
            font-weight: 600;
        }

        /* NEW: Chart View Styles */
        .chart-container {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .chart-title {
            font-weight: 600;
            color: var(--primary);
        }

        .chart-timeframe {
            display: flex;
            gap: 5px;
        }

        .timeframe-btn {
            padding: 5px 10px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .timeframe-btn.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .chart-wrapper {
            position: relative;
            height: 200px;
            width: 100%;
        }

        .chart-loading {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: #666;
            gap: 10px;
        }

        .chart-loading button {
            padding: 8px 16px;
            font-size: 14px;
        }

        /* PayPal Styles */
        .paypal-container {
            margin: 20px 0;
            text-align: center;
        }

        .payment-success {
            text-align: center;
            padding: 20px;
            color: var(--success);
        }

        .payment-success i {
            font-size: 48px;
            margin-bottom: 15px;
        }

        /* M-Pesa Styles */
        .mpesa-container {
            margin: 20px 0;
            text-align: center;
        }

        .payment-method-tabs {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }

        .payment-method-tab {
            flex: 1;
            text-align: center;
            padding: 10px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }

        .payment-method-tab.active {
            border-bottom: 3px solid var(--primary);
            color: var(--primary);
            font-weight: 600;
        }

        .mpesa-phone-input {
            margin-bottom: 15px;
        }

        .mpesa-instructions {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 14px;
        }

        .mpesa-instructions ol {
            text-align: left;
            padding-left: 20px;
        }

        .mpesa-instructions li {
            margin-bottom: 8px;
        }

        .mpesa-status {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid var(--info);
        }

        /* Admin Panel Control Buttons */
        .admin-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .admin-control-btn {
            flex: 1;
            min-width: 150px;
            padding: 12px 15px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .admin-control-btn.users {
            background-color: var(--info);
            color: white;
        }

        .admin-control-btn.transactions {
            background-color: var(--success);
            color: white;
        }

        .admin-control-btn.pending {
            background-color: var(--warning);
            color: white;
        }

        .admin-control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        /* Admin Search Bars */
        .admin-search {
            margin-bottom: 15px;
        }

        .admin-search input {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
        }

        .admin-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        /* Crypto Symbol Colors */
        .crypto-icon.BTC { background-color: #f7931a; color: white; }
        .crypto-icon.ETH { background-color: #627eea; color: white; }
        .crypto-icon.BNB { background-color: #f3ba2f; color: white; }
        .crypto-icon.SOL { background-color: #00ffbd; color: black; }
        .crypto-icon.XRP { background-color: #23292f; color: white; }
        .crypto-icon.ADA { background-color: #0033ad; color: white; }
        .crypto-icon.DOGE { background-color: #c2a633; color: white; }
        .crypto-icon.DOT { background-color: #e6007a; color: white; }
        .crypto-icon.AVAX { background-color: #e84142; color: white; }
        .crypto-icon.LINK { background-color: #2a5ada; color: white; }
        
        .holding-icon.BTC { background-color: #f7931a; color: white; }
        .holding-icon.ETH { background-color: #627eea; color: white; }
        .holding-icon.BNB { background-color: #f3ba2f; color: white; }
        .holding-icon.SOL { background-color: #00ffbd; color: black; }
        .holding-icon.XRP { background-color: #23292f; color: white; }
        .holding-icon.ADA { background-color: #0033ad; color: white; }
        .holding-icon.DOGE { background-color: #c2a633; color: white; }
        .holding-icon.DOT { background-color: #e6007a; color: white; }
        .holding-icon.AVAX { background-color: #e84142; color: white; }
        .holding-icon.LINK { background-color: #2a5ada; color: white; }

        /* Pending Transactions */
        .pending-transaction-item {
            background: #fff9e6;
            border-left: 4px solid var(--warning);
        }

        .pending-actions {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .btn-approve {
            background-color: var(--success);
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-reject {
            background-color: var(--danger);
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Responsive adjustments */
        @media (max-width: 767px) {
            .admin-layout {
                flex-direction: column;
            }
            
            .user-item, .transaction-admin-item {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .user-controls {
                width: 100%;
                margin-top: 10px;
                align-items: flex-start;
            }
            
            .user-actions {
                justify-content: flex-start;
            }
            
            .admin-controls {
                flex-direction: column;
            }
            
            .admin-section-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
        }

        /* Withdrawal Styles */
        .withdrawal-tabs {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }

        .withdrawal-tab {
            flex: 1;
            text-align: center;
            padding: 10px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }

        .withdrawal-tab.active {
            border-bottom: 3px solid var(--primary);
            color: var(--primary);
            font-weight: 600;
        }

        .exchange-rate {
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 14px;
            text-align: center;
        }

        .exchange-rate strong {
            color: var(--primary);
        }

        /* Transaction Hash and Block Number Styles */
        .transaction-hash {
            font-size: 11px;
            color: #666;
            font-family: monospace;
            margin-top: 4px;
            word-break: break-all;
        }

        .block-number {
            font-size: 11px;
            color: #666;
            font-family: monospace;
            margin-top: 2px;
        }

        /* Blocked User Contact Styles */
        .blocked-user-screen {
            text-align: center;
            padding: 20px;
        }

        .blocked-user-screen i {
            font-size: 64px;
            color: var(--danger);
            margin-bottom: 20px;
        }

        .contact-admin-options {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .contact-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            text-align: left;
        }

        .contact-icon {
            font-size: 24px;
            color: var(--primary);
        }

        .contact-details h4 {
            margin: 0 0 5px 0;
        }

        .contact-details p {
            margin: 0;
            color: #666;
            font-size: 14px;
        }

        .copy-btn {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
        }
        
        /* AI Trader Specific Styles */
        .ai-trader-stats {
            margin: 20px 0;
        }

        .pricing-option {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .pricing-option:last-child {
            border-bottom: none;
        }

        .feature {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .feature i {
            margin-right: 8px;
            color: var(--success);
        }

        /* Update existing styles for AI traders */
        .holding-item .crypto-actions {
            display: flex;
            gap: 5px;
        }

        .holding-item .btn-trade {
            padding: 4px 8px;
            font-size: 12px;
        }
        
        /* Identity Management Styles */
        .identity-status-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            border-left: 4px solid var(--primary);
        }

        .status-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .status-header i {
            font-size: 24px;
            color: var(--primary);
        }

        .status-content {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 600;
            color: #666;
        }

        .status-value {
            color: #333;
            font-family: monospace;
            font-size: 14px;
        }

        .document-viewer {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .security-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .security-warning i {
            color: #f39c12;
            margin-top: 2px;
        }

        .security-warning p {
            margin: 0;
            color: #856404;
        }

        .document-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: flex-end;
        }

        .login-options {
            text-align: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .login-options p {
            margin-bottom: 10px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="app-header">
        <div class="container">
            <div class="logo">
                <i class="fas fa-money-bill-wave logo-icon"></i>
                <h1>üá∫üá∏M-USD</h1>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Login/Register Screen -->
        <div id="auth-screen" class="card">
            <h2>Welcome to M-USD</h2>
            <p>Please login or register to continue</p>
            
            <div class="nav-tabs">
                <div class="nav-tab active" id="login-tab">Login</div>
                <div class="nav-tab" id="register-tab">Register</div>
            </div>
            
            <div id="login-form">
                <div class="form-group">
                    <label for="login-phone">Phone Number</label>
                    <input type="tel" id="login-phone" class="form-control" placeholder="07XXXXXXXX">
                </div>
                <div class="form-group">
                    <label for="login-pin">PIN</label>
                    <input type="password" id="login-pin" class="form-control" placeholder="4-digit PIN" maxlength="4">
                </div>
                <button class="btn btn-primary" id="login-btn">Login</button>
                
                <div class="login-options">
                    <p>Advanced login options:</p>
                    <button class="btn btn-outline" id="did-login-option">Login with Digital Identity</button>
                </div>
            </div>
            
            <div id="register-form" class="hidden">
                <div class="form-group">
                    <label for="register-phone">Phone Number</label>
                    <input type="tel" id="register-phone" class="form-control" placeholder="07XXXXXXXX">
                </div>
                <div class="form-group">
                    <label for="register-pin">Create PIN</label>
                    <input type="password" id="register-pin" class="form-control" placeholder="4-digit PIN" maxlength="4">
                </div>
                <div class="form-group">
                    <label for="confirm-pin">Confirm PIN</label>
                    <input type="password" id="confirm-pin" class="form-control" placeholder="Confirm PIN" maxlength="4">
                </div>
                <button class="btn btn-primary" id="register-btn">Register</button>
            </div>
        </div>

        <!-- Blocked User Screen -->
        <div id="blocked-user-screen" class="card hidden">
            <div class="blocked-user-screen">
                <i class="fas fa-ban"></i>
                <h2>üìµAccount Blocked</h2>
                <p>Your account has been blocked. Please contact support to resolve this issue.</p>
                
                <div class="contact-admin-options">
                    <div class="contact-option">
                        <div class="contact-icon">
                            <i class="fas fa-phone"></i>
                        </div>
                        <div class="contact-details">
                            <h4>üìûCall Support</h4>
                            <p>+254 700 000 000</p>
                        </div>
                        <button class="copy-btn" data-text="+254700000000">Copy</button>
                    </div>
                    
                    <div class="contact-option">
                        <div class="contact-icon">
                            <i class="fas fa-envelope"></i>
                        </div>
                        <div class="contact-details">
                            <h4>üì•Email Support</h4>
                            <p>support@m-usd.com</p>
                        </div>
                        <button class="copy-btn" data-text="support@m-usd.com">Copy</button>
                    </div>
                    
                    <div class="contact-option">
                        <div class="contact-icon">
                            <i class="fab fa-whatsapp"></i>
                        </div>
                        <div class="contact-details">
                            <h4>WhatsApp</h4>
                            <p>+254 700 000 000</p>
                        </div>
                        <button class="copy-btn" data-text="+254700000000">Copy</button>
                    </div>
                </div>
                
                <button class="btn btn-outline" id="back-to-login-from-blocked">Back to Login</button>
            </div>
        </div>

        <!-- Dashboard Screen -->
        <div id="dashboard-screen" class="hidden">
            <div class="balance-card">
                <p>Your Balance</p>
                <div class="balance-amount" id="user-balance">USD 0.00</div>
                <p id="user-phone"></p>
            </div>
            
            <div class="menu-grid">
                <div class="menu-item" id="deposit-btn">
                    <div class="menu-icon">
                        <i class="fas fa-money-bill-wave"></i>
                    </div>
                    <div>(Deposit)‚óºÔ∏è(Withdraw)</div>
                </div>
                <div class="menu-item" id="send-money-btn">
                    <div class="menu-icon">
                        <i class="fas fa-paper-plane"></i>
                    </div>
                    <div>Send Money</div>
                </div>
                <div class="menu-item" id="transactions-btn">
                    <div class="menu-icon">
                        <i class="fas fa-history"></i>
                    </div>
                    <div>Transactions</div>
                </div>
                
                <!-- AI Trader Button -->
                <div class="menu-item" id="ai-trader-btn">
                    <div class="menu-icon">
                        <i class="fas fa-robot"></i>
                    </div>
                    <div>AI Traders</div>
                </div>
                
                <div class="menu-item" id="crypto-btn">
                    <div class="menu-icon">
                        <i class="fab fa-bitcoin"></i>
                    </div>
                    <div>Crypto Trading</div>
                </div>

                <!-- Identity Management Button -->
                <div class="menu-item" id="identity-management-btn">
                    <div class="menu-icon">
                        <i class="fas fa-id-card"></i>
                    </div>
                    <div>Identity Management</div>
                </div>


<div class="menu-item" onclick="window.location.href='iot-real.html'">
    <div class="iot-icon">
        <i class="fas fa-external-link-alt"></i>
    </div>
    <div>üì°IOT Devices</div>
</div>
    <div class="menu-item" onclick="window.location.href='ai.html'">
    <div class="ai-icon">
        <i class="fas fa-external-link-alt"></i>
    </div>
    <div>ü§ñ AI</div>
</div>
                <div class="menu-item" onclick="window.location.href='fed.html'">
    <div class="chat-icon">
        <i class="fas fa-external-link-alt"></i>
    </div>
    <div>üí¨ Chat</div>
</div>

<div class="menu-item" onclick="window.location.href='child.html'">
    <div class="game-icon">
        <i class="fas fa-external-link-alt"></i>
    </div>
    <div>ü§ñ Games</div>
        </div>


                
                <div class="menu-item" id="admin-btn">
                    <div class="menu-icon">
                        <i class="fas fa-cog"></i>
                    </div>
                    <div>Admin</div>
                </div>
            </div>
            
            <button class="btn btn-outline" id="logout-btn">Logout</button>
        </div>

        <!-- Deposit/Withdraw Screen -->
        <div id="deposit-screen" class="card hidden">
            <h2>(Deposit)(Withdraw)</h2>
            
            <!-- Deposit/Withdraw Tabs -->
            <div class="withdrawal-tabs">
                <div class="withdrawal-tab active" id="deposit-tab">üü¢Deposit</div>
                <div class="withdrawal-tab" id="withdraw-tab">üî¥Withdraw</div>
            </div>
            
            <!-- Payment Method Tabs -->
            <div class="payment-method-tabs">
                <div class="payment-method-tab active" id="paypal-tab">üí∂PayPal</div>
                <div class="payment-method-tab" id="mpesa-tab">üíµM-Pesa</div>
            </div>
            
            <!-- Deposit Section -->
            <div id="deposit-section">
                <div class="form-group">
                    <label for="deposit-amount">Enter Amount (USD)</label>
                    <input type="number" id="deposit-amount" class="form-control" placeholder="Enter amount" min="5" max="10000" step="0.01">
                </div>
                <div class="form-group">
                    <p>‚ñ™Ô∏èMinimum deposit: $5.00</p>
                    <p>‚óºÔ∏èMaximum deposit: $10,000.00</p>
                </div>
                
                <!-- Exchange Rate Info for M-Pesa -->
                <div id="deposit-exchange-rate" class="exchange-rate hidden">
                    <p><strong>üìäExchange Rate:</strong> 1 USD = Ksh 135</p>
                    <p id="deposit-ksh-amount">üåÄEquivalent: Ksh 0.00</p>
                </div>
                
                <!-- PayPal Payment Method -->
                <div id="paypal-method">
                    <div class="paypal-container" id="paypal-container"></div>
                    <div class="payment-notice">
                        <p><strong>üìåNote:</strong> Your PayPal deposit will be pending until verified by system.You'll receive a notification once approved.</p>
                    </div>
                </div>
                
                <!-- M-Pesa Payment Method -->
                <div id="mpesa-method" class="hidden">
                    <div class="mpesa-container">
                        <div class="form-group mpesa-phone-input">
                            <label for="mpesa-phone">M-Pesa Phone Number</label>
                            <input type="tel" id="mpesa-phone" class="form-control" placeholder="2547XXXXXXXX" value="">
                        </div>
                        
                        <div class="mpesa-instructions">
                            <h4>How to deposit with M-Pesa:</h4>
                            <ol>
                                <li>Go to your M-Pesa send money</li>
                                <li>Enter the deposit amount in Ksh as show in the converter to 0746500025</li>
                                <li>Enter your M-Pesa PIN to complete payment</li>
                                <li>Wait for system verification (usually within 24 hours)</li>
                            </ol>
                        </div>
                        
                        <button class="btn btn-primary" id="mpesa-deposit-btn">
                            <i class="fas fa-mobile-alt"></i> üü¢Deposit with M-Pesa
                        </button>
                        
                        <div id="mpesa-status" class="mpesa-status hidden">
                            <p id="mpesa-status-text">‚è≥Processing...</p>
                        </div>
                        
                        <div class="payment-notice">
                            <p><strong>‚öôÔ∏èNote:</strong> Your deposit will be pending until verified by system. You'll receive a notification once approved.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Withdraw Section -->
            <div id="withdraw-section" class="hidden">
                <div class="form-group">
                    <label for="withdraw-amount">Enter Amount (USD)</label>
                    <input type="number" id="withdraw-amount" class="form-control" placeholder="Enter amount" min="5" max="10000" step="0.01">
                </div>
                <div class="form-group">
                    <p>‚ñ™Ô∏èMinimum withdrawal: $5.00</p>
                    <p>‚óºÔ∏èMaximum withdrawal: $10,000.00</p>
                </div>
                
                <!-- Exchange Rate Info for M-Pesa -->
                <div id="withdraw-exchange-rate" class="exchange-rate hidden">
                    <p><strong>üìäExchange Rate:</strong> 1 USD = Ksh 125</p>
                    <p id="withdraw-ksh-amount">üåÄEquivalent: Ksh 0.00</p>
                </div>
                
                <!-- PayPal Withdraw Method -->
                <div id="paypal-withdraw-method">
                    <div class="form-group">
                        <label for="paypal-email">üÖøÔ∏èPayPal Email</label>
                        <input type="email" id="paypal-email" class="form-control" placeholder="your-email@example.com">
                    </div>
                    
                    <div class="mpesa-instructions">
                        <h4>How to withdraw with PayPal:</h4>
                        <ol>
                            <li>Enter your PayPal email address above</li>
                            <li>Enter the withdrawal amount in USD</li>
                            <li>Click "Withdraw with PayPal"</li>
                            <li>Wait for system verification (usually within 24 hours)</li>
                            <li>Funds will be sent to your PayPal account</li>
                        </ol>
                    </div>
                    
                    <button class="btn btn-primary" id="paypal-withdraw-btn">
                        <i class="fab fa-paypal"></i> Withdraw with PayPal
                    </button>
                </div>
                
                <!-- M-Pesa Withdraw Method -->
                <div id="mpesa-withdraw-method" class="hidden">
                    <div class="mpesa-container">
                        <div class="form-group mpesa-phone-input">
                            <label for="mpesa-withdraw-phone">M-Pesa Phone Number</label>
                            <input type="tel" id="mpesa-withdraw-phone" class="form-control" placeholder="2547XXXXXXXX" value="">
                        </div>
                        
                        <div class="mpesa-instructions">
                            <h4>How to withdraw with M-Pesa:</h4>
                            <ol>
                                <li>Enter your M-Pesa phone number above</li>
                                <li>Enter the withdrawal amount in USD</li>
                                <li>Click "Withdraw with M-Pesa"</li>
                                <li>Wait for system verification (usually within 24 hours)</li>
                                <li>Funds will be sent to your M-Pesa account in Ksh </li>
                            </ol>
                        </div>
                        
                        <button class="btn btn-primary" id="mpesa-withdraw-btn">
                            <i class="fas fa-mobile-alt"></i> Withdraw with M-Pesa
                        </button>
                        
                        <div id="mpesa-withdraw-status" class="mpesa-status hidden">
                            <p id="mpesa-withdraw-status-text">‚è≥Processing...</p>
                        </div>
                    </div>
                </div>
                
                <div class="payment-notice">
                    <p><strong>‚öôÔ∏èNote:</strong> Your withdrawal will be pending until verified by system. You'll receive a notification once approved.</p>
                </div>
            </div>
            
            <button class="btn btn-outline" id="back-from-deposit">Back</button>
        </div>

        <!-- Payment Pending Screen -->
        <div id="payment-pending-screen" class="card hidden">
            <div class="payment-success">
                <i class="fas fa-clock"></i>
                <h2>‚è≥Payment Pending Verification</h2>
                <p>Your <span id="pending-type">deposit</span> is pending system verification.</p>
                <p>Amount: <span id="pending-deposit-amount">USD 0.00</span></p>
                <p>Method: <span id="pending-deposit-method">PayPal</span></p>
                <p>You will be notified once your <span id="pending-type2">deposit</span> is approved.</p>
                <button class="btn btn-primary" id="back-to-dashboard-from-pending">Back to Dashboard</button>
            </div>
        </div>

        <!-- Payment Success Screen -->
        <div id="payment-success-screen" class="card hidden">
            <div class="payment-success">
                <i class="fas fa-check-circle"></i>
                <h2>‚úÖPayment Successful!</h2>
                <p>Your <span id="success-type">deposit</span> has been processed successfully.</p>
                <p>Amount: <span id="deposit-success-amount">USD 0.00</span></p>
                <p>Method: <span id="deposit-method">PayPal</span></p>
                <button class="btn btn-primary" id="back-to-dashboard">Back to Dashboard</button>
            </div>
        </div>

        <!-- Send Money Screen -->
        <div id="send-money-screen" class="card hidden">
            <h2>Send Money</h2>
            <div class="form-group">
                <label for="recipient-phone">Recipient Phone Number</label>
                <input type="tel" id="recipient-phone" class="form-control" placeholder="07XXXXXXXX">
            </div>
            <div class="form-group">
                <label for="send-amount">Amount (USD)</label>
                <input type="number" id="send-amount" class="form-control" placeholder="Enter amount">
            </div>
            <div class="form-group">
                <p>Transaction Fee (1%): <span id="transaction-fee">USD 0.00</span></p>
                <p>Total Deducted: <span id="total-deducted">USD 0.00</span></p>
            </div>
            <button class="btn btn-primary" id="confirm-send">Send Money</button>
            <button class="btn btn-outline" id="back-from-send">Back</button>
        </div>

        <!-- Transactions Screen -->
        <div id="transactions-screen" class="card hidden">
            <h2>üìëTransaction History</h2>
            <div id="transactions-list">
                <!-- Transactions will be populated here -->
            </div>
            <button class="btn btn-outline" id="back-from-transactions">Back</button>
        </div>

        <!-- Crypto Trading Screen -->
        <div id="crypto-trading-screen" class="card hidden">
            <h2>üìâüìàCrypto Trading Platform</h2>
            
            <!-- Portfolio Summary -->
            <div class="portfolio-summary">
                <div class="portfolio-card">
                    <h3>‚ö´üî¥‚ö™Your Portfolio</h3>
                    <div class="portfolio-balance">
                        <div class="total-value">
                            <span class="label">Total Value:</span>
                            <span class="amount" id="portfolio-total">USD 0.00</span>
                        </div>
                        <div class="breakdown">
                            <div class="breakdown-item">
                                <span class="label">ü•áCash Balance:</span>
                                <span class="amount" id="portfolio-cash">USD 0.00</span>
                            </div>
                            <div class="breakdown-item">
                                <span class="label">ü•àCrypto Value:</span>
                                <span class="amount" id="portfolio-crypto">USD 0.00</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Crypto Holdings -->
            <div class="crypto-holdings">
                <h3>üèßYour Crypto Holdings</h3>
                <div id="crypto-holdings-list">
                    <!-- Crypto holdings will be populated here -->
                </div>
            </div>
            
            <!-- Top Cryptocurrencies -->
            <div class="crypto-market">
                <h3>Top 10 Cryptocurrencies</h3>
                <div class="search-bar">
                    <input type="text" id="crypto-search" class="form-control" placeholder="Search cryptocurrencies...">
                </div>
                <div id="crypto-list">
                    <!-- Cryptocurrencies will be populated here -->
                </div>
            </div>
            
            <button class="btn btn-outline" id="back-from-crypto">Back to Dashboard</button>
        </div>

        <!-- AI Traders Screen -->
        <div id="ai-trader-screen" class="card hidden">
            <h2>ü§ñ AI Trading Platform</h2>
            
            <!-- User AI Traders Dashboard -->
            <div class="portfolio-summary">
                <div class="portfolio-card">
                    <h3>My AI Traders</h3>
                    <div class="portfolio-balance">
                        <div class="total-value">
                            <span class="label">Active AI Traders:</span>
                            <span class="amount" id="active-ai-count">0</span>
                        </div>
                        <div class="breakdown">
                            <div class="breakdown-item">
                                <span class="label">Total Investment:</span>
                                <span class="amount" id="total-ai-investment">USD 0.00</span>
                            </div>
                            <div class="breakdown-item">
                                <span class="label">Total Profit:</span>
                                <span class="amount positive" id="total-ai-profit">USD 0.00</span>
                            </div>
                            <div class="breakdown-item">
                                <span class="label">Success Rate:</span>
                                <span class="amount" id="ai-success-rate">0%</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- My Active AI Traders -->
            <div class="crypto-holdings">
                <h3>My Active AI Traders</h3>
                <div id="my-ai-traders-list">
                    <!-- Active AI traders will be populated here -->
                </div>
            </div>
            
            <!-- Available AI Traders -->
            <div class="crypto-market">
                <h3>Available AI Traders</h3>
                <div class="search-bar">
                    <input type="text" id="ai-search" class="form-control" placeholder="Search AI traders...">
                </div>
                <div id="ai-trader-list">
                    <!-- AI traders will be populated here -->
                </div>
            </div>
            
            <button class="btn btn-outline" id="back-from-ai">Back to Dashboard</button>
        </div>

        <!-- Identity Management Screen -->
        <div id="identity-management-screen" class="card hidden">
            <h2>Decentralized Identity Management</h2>
            
            <div class="identity-status-card">
                <div class="status-header">
                    <i class="fas fa-fingerprint"></i>
                    <h3>Your Digital Identity</h3>
                </div>
                <div id="did-status" class="status-content">
                    <!-- DID status will be populated here -->
                </div>
            </div>
            
            <div class="identity-actions">
                <div class="menu-grid">
                    <div class="menu-item" id="export-identity-btn">
                        <div class="menu-icon">
                            <i class="fas fa-download"></i>
                        </div>
                        <div>Export Identity</div>
                    </div>
                    
                    <div class="menu-item" id="import-identity-btn">
                        <div class="menu-icon">
                            <i class="fas fa-upload"></i>
                        </div>
                        <div>Import Identity</div>
                    </div>
                    
                    <div class="menu-item" id="backup-dwn-btn">
                        <div class="menu-icon">
                            <i class="fas fa-database"></i>
                        </div>
                        <div>Backup DWN Data</div>
                    </div>
                    
                    <div class="menu-item" id="restore-dwn-btn">
                        <div class="menu-icon">
                            <i class="fas fa-history"></i>
                        </div>
                        <div>Restore DWN Data</div>
                    </div>
                    
                    <div class="menu-item" id="view-did-document-btn">
                        <div class="menu-icon">
                            <i class="fas fa-file-alt"></i>
                        </div>
                        <div>View DID Document</div>
                    </div>
                    
                    <div class="menu-item" id="sync-devices-btn">
                        <div class="menu-icon">
                            <i class="fas fa-sync-alt"></i>
                        </div>
                        <div>Sync Devices</div>
                    </div>
                </div>
            </div>
            
            
            
<div class="menu-item" id="verifiable-credentials-btn">
    <div class="menu-icon">
        <i class="fas fa-certificate"></i>
    </div>
    <div>Verifiable Credentials</div>
</div>

<!-- Add VC Management Screen -->
<div id="vc-management-screen" class="card hidden">
    <h2>üé´ Verifiable Credentials</h2>
    
    <div class="vc-issuance">
        <h3>Issue Credentials</h3>
        <button class="btn btn-primary" id="issue-kyc-certificate">
            <i class="fas fa-id-card"></i> Issue KYC Certificate
        </button>
        <button class="btn btn-primary" id="issue-trading-certificate">
            <i class="fas fa-chart-line"></i> Issue Trading Certificate
        </button>
    </div>
    
    <div class="vc-wallet">
        <h3>Your Credentials</h3>
        <div id="vc-list">
            <!-- VCs will be populated here -->
        </div>
    </div>
    
    <button class="btn btn-outline" id="back-from-vc">Back</button>
</div>
            
            
            
            
            
            <button class="btn btn-outline" id="back-from-identity">Back to Dashboard</button>
        </div>

        <!-- Admin Panel -->
        <div id="admin-panel" class="admin-panel hidden">
            <h2>Admin Panel</h2>
            
            <!-- Admin Control Buttons -->
            <div class="admin-controls">
                <button class="admin-control-btn users" id="show-users-btn">
                    <i class="fas fa-users"></i> Show All Users
                </button>
                <button class="admin-control-btn transactions" id="show-transactions-btn">
                    <i class="fas fa-exchange-alt"></i> Show All Transactions
                </button>
                <button class="admin-control-btn pending" id="show-pending-btn">
                    <i class="fas fa-clock"></i> Pending Deposits
                </button>
                <button class="admin-control-btn pending" id="show-pending-withdrawals-btn">
                    <i class="fas fa-clock"></i> Pending Withdrawals
                </button>
            </div>
            
            <div class="admin-layout">
                <!-- Users Section (Hidden by Default) -->
                <div class="admin-section hidden" id="users-section">
                    <div class="admin-section-header">
                        <h3>All Users</h3>
                        <button class="btn btn-outline" id="hide-users-btn">
                            <i class="fas fa-times"></i> Hide Users
                        </button>
                    </div>
                    
                    <!-- User Search -->
                    <div class="admin-search">
                        <input type="text" id="user-search" class="form-control" placeholder="Search users by phone number...">
                    </div>
                    
                    <div id="users-list">
                        <!-- Users will be populated here -->
                    </div>
                </div>
                
                <!-- Transactions Section (Hidden by Default) -->
                <div class="admin-section hidden" id="transactions-section">
                    <div class="admin-section-header">
                        <h3>All Transactions</h3>
                        <button class="btn btn-outline" id="hide-transactions-btn">
                            <i class="fas fa-times"></i> Hide Transactions
                        </button>
                    </div>
                    
                    <!-- Transaction Search -->
                    <div class="admin-search">
                        <input type="text" id="transaction-search" class="form-control" placeholder="Search transactions by phone, type, or method...">
                    </div>
                    
                    <div id="admin-transactions-list">
                        <!-- All transactions will be populated here -->
                    </div>
                </div>
                
                <!-- Pending Deposits Section (Hidden by Default) -->
                <div class="admin-section hidden" id="pending-section">
                    <div class="admin-section-header">
                        <h3>Pending Deposits</h3>
                        <button class="btn btn-outline" id="hide-pending-btn">
                            <i class="fas fa-times"></i> Hide Pending
                        </button>
                    </div>
                    
                    <div id="pending-deposits-list">
                        <!-- Pending deposits will be populated here -->
                    </div>
                </div>
                
                <!-- Pending Withdrawals Section (Hidden by Default) -->
                <div class="admin-section hidden" id="pending-withdrawals-section">
                    <div class="admin-section-header">
                        <h3>Pending Withdrawals</h3>
                        <button class="btn btn-outline" id="hide-pending-withdrawals-btn">
                            <i class="fas fa-times"></i> Hide Pending
                        </button>
                    </div>
                    
                    <div id="pending-withdrawals-list">
                        <!-- Pending withdrawals will be populated here -->
                    </div>
                </div>
            </div>
            
            <button class="btn btn-outline" id="back-from-admin">Back to Dashboard</button>
        </div>

        <!-- Loading Indicator -->
        <div id="loading-screen" class="card hidden">
            <div class="loading">
                <div class="spinner"></div>
                <p>‚è≥Loading...</p>
            </div>
        </div>
    </div>

    <!-- Deduction Modal -->
    <div id="deduction-modal" class="deduction-modal hidden">
        <div class="deduction-modal-content">
            <div class="deduction-modal-header">
                <h2>Deduct Funds</h2>
                <span class="close-deduction-modal" id="close-deduction-modal">&times;</span>
            </div>
            <div class="deduction-user-info" id="deduction-user-info">
                <!-- User info will be populated here -->
            </div>
            <div class="deduction-form-group">
                <label for="deduction-amount">Amount to Deduct (USD)</label>
                <input type="number" id="deduction-amount" class="deduction-form-control" placeholder="Enter amount" min="0.01" step="0.01">
            </div>
            <div class="deduction-form-group">
                <label for="deduction-reason">Reason for Deduction</label>
                <textarea id="deduction-reason" class="deduction-form-control" placeholder="Enter reason for deduction" rows="3"></textarea>
            </div>
            <div class="deduction-actions">
                <button class="btn btn-cancel" id="cancel-deduction">Cancel</button>
                <button class="btn btn-deduct" id="confirm-deduction">Deduct Funds</button>
            </div>
        </div>
    </div>

    <!-- Hire AI Modal -->
    <div id="hire-ai-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="hire-ai-title">Hire AI Trader</h2>
                <span class="close-modal" id="close-hire-modal">&times;</span>
            </div>
            <div class="modal-body">
                <div id="ai-trader-info">
                    <!-- AI trader info will be populated here -->
                </div>
                
                <div class="form-group">
                    <label for="investment-amount">Investment Amount (USD)</label>
                    <input type="number" id="investment-amount" class="form-control" placeholder="Enter amount" min="50" step="1">
                    <small>Minimum investment: $50</small>
                </div>
                
                <div class="form-group">
                    <label for="duration">Hiring Duration</label>
                    <select id="duration" class="form-control">
                        <option value="7">1 Week - $10</option>
                        <option value="30">1 Month - $35</option>
                        <option value="90">3 Months - $90</option>
                        <option value="180">6 Months - $160</option>
                        <option value="365">1 Year - $280</option>
                    </select>
                </div>
                
                <div class="exchange-rate">
                    <div class="pricing-option">
                        <span>Investment Amount:</span>
                        <span id="display-investment">USD 0.00</span>
                    </div>
                    <div class="pricing-option">
                        <span>AI Fee:</span>
                        <span id="display-fee">USD 0.00</span>
                    </div>
                    <div class="pricing-option">
                        <span><strong>Total Cost:</strong></span>
                        <span><strong id="display-total">USD 0.00</strong></span>
                    </div>
                </div>
                
                <div class="modal-actions">
                    <button class="btn btn-outline" id="cancel-hire">Cancel</button>
                    <button class="btn btn-primary" id="confirm-hire">
                        <i class="fas fa-robot"></i> Hire AI Trader
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- DID Login Modal -->
    <div id="did-login-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2>DID Authentication</h2>
                <span class="close-modal" id="close-did-login">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="did-phone">Phone Number</label>
                    <input type="tel" id="did-phone" class="form-control" placeholder="07XXXXXXXX">
                </div>
                <div class="form-group">
                    <label for="did-signature">Digital Signature</label>
                    <input type="password" id="did-signature" class="form-control" placeholder="Enter your digital signature">
                </div>
                <button class="btn btn-primary" id="did-login-btn">Login with DID</button>
                
                <div class="login-options">
                    <p>Or login with:</p>
                    <button class="btn btn-outline" id="traditional-login-fallback">Traditional PIN</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Export Identity Modal -->
    <div id="export-identity-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Export Digital Identity</h2>
                <span class="close-modal" id="close-export-identity">&times;</span>
            </div>
            <div class="modal-body">
                <div class="security-warning">
                    <i class="fas fa-exclamation-triangle"></i>
                    <p><strong>Security Warning:</strong> Your identity file contains sensitive information. Store it securely and don't share with anyone.</p>
                </div>
                
                <div class="form-group">
                    <label for="export-password">Encryption Password</label>
                    <input type="password" id="export-password" class="form-control" placeholder="Enter strong password">
                </div>
                
                <div class="form-group">
                    <label for="confirm-export-password">Confirm Password</label>
                    <input type="password" id="confirm-export-password" class="form-control" placeholder="Confirm password">
                </div>
                
                <div class="modal-actions">
                    <button class="btn btn-outline" id="cancel-export">Cancel</button>
                    <button class="btn btn-primary" id="confirm-export">Export Identity</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Import Identity Modal -->
    <div id="import-identity-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Import Digital Identity</h2>
                <span class="close-modal" id="close-import-identity">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="identity-file">Select Identity Backup File</label>
                    <input type="file" id="identity-file" class="form-control" accept=".json">
                </div>
                
                <div class="form-group">
                    <label for="import-password">Backup Password</label>
                    <input type="password" id="import-password" class="form-control" placeholder="Enter backup password">
                </div>
                
                <div class="form-group">
                    <label for="import-phone">Phone Number</label>
                    <input type="tel" id="import-phone" class="form-control" placeholder="07XXXXXXXX">
                </div>
                
                <div class="modal-actions">
                    <button class="btn btn-outline" id="cancel-import">Cancel</button>
                    <button class="btn btn-primary" id="confirm-import">Import Identity</button>
                </div>
            </div>
        </div>
    </div>

    <!-- DID Document Viewer -->
    <div id="did-document-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2>DID Document</h2>
                <span class="close-modal" id="close-did-document">&times;</span>
            </div>
            <div class="modal-body">
                <pre id="did-document-content" class="document-viewer"></pre>
                <div class="document-actions">
                    <button class="btn btn-outline" id="copy-did-document">Copy to Clipboard</button>
                    <button class="btn btn-primary" id="download-did-document">Download</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div id="notification" class="notification"></div>

    <div class="footer">
        <p>üá∫üá∏M-USD &copy; 2025-2026 | Transparent‚Ä¢Simple‚Ä¢Honest</p>
    </div>

    <!-- PayPal SDK -->
    <script src="https://www.paypal.com/sdk/js?client-id=BAACQuXuWBU-kINGYikHAl1SJbKvE39-jQgtC-83wwy2341zOdFtP0N4owr_xBsaUqGBUWgPajOljdo_Eo&components=hosted-buttons&disable-funding=venmo&currency=USD"></script>

    <!-- Include JavaScript files -->
    <script src="did-manager.js"></script>
    <script src="dwn-manager.js"></script>



<!-- EMERGENCY VC FIX -->
<div id="emergency-vc-screen" class="card hidden">
    <h2>üé´ Verifiable Credentials (Emergency Mode)</h2>
    
    <div style="text-align: center; padding: 40px 20px;">
        <div style="font-size: 64px; color: #00a651; margin-bottom: 20px;">
            <i class="fas fa-certificate"></i>
        </div>
        <h3>Web5 Digital Credentials</h3>
        <p>Issue and manage verifiable credentials on the decentralized web</p>
        
        <div style="margin: 30px 0;">
            <button class="btn btn-primary" style="margin: 10px; padding: 15px 25px;" onclick="issueEmergencyCredential('kyc')">
                <i class="fas fa-id-card"></i> Issue KYC Certificate
            </button>
            <button class="btn btn-primary" style="margin: 10px; padding: 15px 25px;" onclick="issueEmergencyCredential('trading')">
                <i class="fas fa-chart-line"></i> Issue Trading Certificate
            </button>
        </div>
        
        <div id="emergency-credentials-list" style="margin-top: 30px;">
            <!-- Credentials will appear here -->
        </div>
    </div>
    
    <button class="btn btn-outline" onclick="hideEmergencyVCScreen()" style="margin-top: 20px;">Back</button>
</div>

<script>
    // ULTIMATE VC FIX - 100% WORKING
    console.log('=== EMERGENCY VC FIX ACTIVATED ===');
    
    // 1. FIRST: Replace the broken VC button with a working one
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
            console.log('Replacing VC button...');
            
            // Find the original VC button
            const originalBtn = document.getElementById('verifiable-credentials-btn');
            
            if (originalBtn) {
                console.log('Found VC button, replacing...');
                
                // Create a brand new button
                const newBtn = document.createElement('div');
                newBtn.className = 'menu-item';
                newBtn.innerHTML = `
                <div class="menu-icon">
                    <i class="fas fa-certificate"></i>
                </div>
                <div>Verifiable Credentials</div>
            `;
                newBtn.style.cursor = 'pointer';
                
                // Replace the old button
                originalBtn.parentNode.replaceChild(newBtn, originalBtn);
                
                // Add click event that DEFINITELY works
                newBtn.addEventListener('click', function() {
                    console.log('EMERGENCY VC BUTTON CLICKED!');
                    
                    // Hide everything
                    document.querySelectorAll('.card, [id$="-screen"]').forEach(el => {
                        if (el.id !== 'emergency-vc-screen') {
                            el.classList.add('hidden');
                        }
                    });
                    
                    // Show emergency VC screen
                    const emergencyScreen = document.getElementById('emergency-vc-screen');
                    if (emergencyScreen) {
                        emergencyScreen.classList.remove('hidden');
                        console.log('Emergency VC screen shown!');
                        
                        // Add some sample credentials for demo
                        const list = document.getElementById('emergency-credentials-list');
                        if (list.innerHTML === '') {
                            list.innerHTML = `
                            <div style="text-align: left; margin-top: 20px;">
                                <p><strong>Sample Credentials:</strong></p>
                                <div class="transaction-item" style="margin: 10px 0;">
                                    <div class="transaction-details">
                                        <div class="transaction-type">Demo KYC Certificate</div>
                                        <div class="transaction-date">Issued: Just now</div>
                                        <div class="transaction-parties">Status: Verified</div>
                                    </div>
                                    <div class="transaction-amount">
                                        <button class="btn btn-outline" onclick="viewEmergencyCredential('kyc')">View</button>
                                    </div>
                                </div>
                            </div>
                        `;
                        }
                    }
                });
                
                console.log('VC button replaced successfully!');
            }
        }, 500);
    });
    
    // 2. Issue emergency credential
    window.issueEmergencyCredential = function(type) {
        console.log(`Issuing ${type} credential...`);
        
        const list = document.getElementById('emergency-credentials-list');
        if (!list) return;
        
        const credentialId = Date.now();
        const types = {
            kyc: {
                title: 'KYC Identity Certificate',
                icon: 'fa-id-card',
                level: 'Verified',
                issuer: 'M-USD Authority'
            },
            trading: {
                title: 'Trading License',
                icon: 'fa-chart-line',
                level: 'Intermediate',
                issuer: 'M-USD Trading'
            }
        };
        
        const cred = types[type] || types.kyc;
        
        const credentialHTML = `
        <div class="transaction-item" id="cred-${credentialId}" style="margin: 10px 0; animation: fadeIn 0.5s;">
            <div class="transaction-details">
                <div class="transaction-type">
                    <i class="fas ${cred.icon}"></i> ${cred.title}
                </div>
                <div class="transaction-date">Issued: ${new Date().toLocaleTimeString()}</div>
                <div class="transaction-parties">Level: ${cred.level}</div>
                <div class="transaction-method">Issuer: ${cred.issuer}</div>
                <div class="transaction-fee">Web5 Decentralized</div>
            </div>
            <div class="transaction-amount">
                <button class="btn btn-outline" onclick="viewEmergencyCredential('${type}', ${credentialId})">
                    View
                </button>
                <button class="btn btn-outline" onclick="downloadEmergencyCredential('${type}', ${credentialId})">
                    Export
                </button>
            </div>
        </div>
    `;
        
        list.insertAdjacentHTML('afterbegin', credentialHTML);
        
        // Show success message
        showEmergencyNotification(`‚úÖ ${cred.title} issued successfully!`);
    };
    
    // 3. View credential
    window.viewEmergencyCredential = function(type, id) {
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 10000;';
        
        modal.innerHTML = `
        <div style="background: white; border-radius: 12px; max-width: 500px; width: 90%; padding: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 10px;">
                <h2 style="margin: 0; color: #00a651;">Verifiable Credential</h2>
                <span style="font-size: 24px; cursor: pointer;" onclick="this.parentElement.parentElement.parentElement.remove()">&times;</span>
            </div>
            <div style="padding: 20px;">
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 64px; color: #00a651;">
                        <i class="fas fa-certificate"></i>
                    </div>
                    <h3>${type === 'kyc' ? 'KYC Identity Certificate' : 'Trading License'}</h3>
                </div>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <p><strong>Credential ID:</strong> cred-${id || 'demo'}</p>
                    <p><strong>Issued:</strong> ${new Date().toLocaleString()}</p>
                    <p><strong>Type:</strong> VerifiableCredential</p>
                    <p><strong>Format:</strong> W3C Verifiable Credential</p>
                    <p><strong>Storage:</strong> Decentralized Web Node (DWN)</p>
                    <p><strong>Verification:</strong> Cryptographically Signed</p>
                </div>
                <p style="text-align: center; color: #666; font-size: 14px;">
                    This credential demonstrates Web5 decentralized identity capabilities
                </p>
                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="this.parentElement.parentElement.parentElement.parentElement.remove()">
                        Close
                    </button>
                </div>
            </div>
        </div>
    `;
        
        document.body.appendChild(modal);
    };
    
    // 4. Download credential
    window.downloadEmergencyCredential = function(type, id) {
        const credentialData = {
            "@context": [
                "https://www.w3.org/2018/credentials/v1",
                "https://m-usd.com/credentials/v1"
            ],
            "id": `https://m-usd.com/credentials/${id}`,
            "type": ["VerifiableCredential", type === 'kyc' ? "KYCIdentityCredential" : "CryptoTradingCredential"],
            "issuer": "did:musd:issuer:authority",
            "issuanceDate": new Date().toISOString(),
            "credentialSubject": {
                "id": `did:musd:user:${id}`,
                "type": type,
                "status": "active",
                "issued": new Date().toISOString()
            },
            "proof": {
                "type": "Ed25519Signature2020",
                "created": new Date().toISOString(),
                "proofPurpose": "assertionMethod",
                "verificationMethod": "did:musd:issuer:authority#key-1",
                "jws": "eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..demo-signature"
            }
        };
        
        const dataStr = JSON.stringify(credentialData, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `musd-${type}-credential-${id}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showEmergencyNotification('üì• Credential downloaded as JSON file!');
    };
    
    // 5. Hide screen
    window.hideEmergencyVCScreen = function() {
        document.getElementById('emergency-vc-screen').classList.add('hidden');
        document.getElementById('identity-management-screen').classList.remove('hidden');
    };
    
    // 6. Notification function
    function showEmergencyNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 20px;
        background: #00a651;
        color: white;
        border-radius: 8px;
        z-index: 10001;
        font-weight: bold;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        animation: slideIn 0.3s ease;
    `;
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.remove();
        }, 3000);
    }
    
    // 7. Add CSS animations
    const emergencyStyle = document.createElement('style');
    emergencyStyle.textContent = `
    @keyframes slideIn {
        from { transform: translateX(100px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    .hidden { display: none !important; }
`;
    document.head.appendChild(emergencyStyle);
    
    console.log('=== EMERGENCY VC FIX READY ===');
    console.log('VC button will work in 0.5 seconds...');
</script>




<script type="module">
    // Import Firebase modules
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
    import { getDatabase, ref, set, get, push, update, query, orderByChild, onValue, remove } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-database.js";

    // Firebase configuration
    const firebaseConfig = {
        apiKey: "AIzaSyDfP7BSZB7kufh4yrSdpDn14kIdbF9SJdc",
        authDomain: "m-usd-e3555.firebaseapp.com",
        databaseURL: "https://m-usd-e3555-default-rtdb.firebaseio.com",
        projectId: "m-usd-e3555",
        storageBucket: "m-usd-e3555.firebasestorage.app",
        messagingSenderId: "966918203590",
        appId: "1:966918203590:web:b19913384b906a472d0fc7",
        measurementId: "G-Y3X5T8GSNC"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);

    // Initialize DID and DWN Managers
    const didManager = new DIDManager();
    const dwnManager = new DWNManager();

    // Make them globally available
    window.didManager = didManager;
    window.dwnManager = dwnManager;

    // M-Pesa Configuration
    const MPESA_CONFIG = {
        CONSUMER_KEY: 'qvBMMqTOzWWjPUKSVL9fqnOgeumfflUp3BCDVRARRbOOJBA',
        CONSUMER_SECRET: '33q8Rz2eGBlwBjy84IGYhdXiOaRyzcIV2IXkyOAeLHJ9AARVyiqdGKqRIX28qYcu',
        BUSINESS_SHORTCODE: '174379',
        PASSKEY: 'bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919',
        CALLBACK_URL: 'https://yourwebsite.com/mpesa-callback',
        ENVIRONMENT: 'sandbox'
    };

    // App Configuration
    const CONFIG = {
        PAYMENTS: {
            MIN_DEPOSIT: 5,
            MAX_DEPOSIT: 10000,
            MIN_WITHDRAWAL: 5,
            MAX_WITHDRAWAL: 10000
        },
        EXCHANGE_RATES: {
            DEPOSIT: 135, // 1 USD = Ksh 135 for deposits
            WITHDRAWAL: 125 // 1 USD = Ksh 125 for withdrawals
        }
    };

    // AI Trader Configuration
    const AI_TRADERS = [
        {
            id: 'ai-1',
            name: 'Quantum Pulse',
            avatar: '‚ö°',
            color: 'BTC',
            strategy: 'High-Frequency Arbitrage',
            description: 'Specializes in micro-second opportunities across multiple exchanges. Identifies price discrepancies and executes rapid trades.',
            performance: 24.7,
            riskLevel: 'Medium',
            winRate: 78,
            avgTradeSize: 150,
            features: ['24/7 Monitoring', 'Multi-Exchange', 'Risk Management', 'Real-time Analysis'],
            fee: 10,
            algorithm: 'arbitrage'
        },
        {
            id: 'ai-2',
            name: 'Neural Navigator',
            avatar: 'üß†',
            color: 'ETH',
            strategy: 'Deep Learning Prediction',
            description: 'Uses advanced neural networks to predict market movements based on historical data and sentiment analysis.',
            performance: 18.3,
            riskLevel: 'Low',
            winRate: 82,
            avgTradeSize: 200,
            features: ['AI Prediction', 'Sentiment Analysis', 'Pattern Recognition', 'Adaptive Learning'],
            fee: 12,
            algorithm: 'neural_network'
        },
        {
            id: 'ai-3',
            name: 'Crypto Sentinel',
            avatar: 'üõ°Ô∏è',
            color: 'BNB',
            strategy: 'Risk-Averse Growth',
            description: 'Focuses on steady growth with maximum capital protection. Ideal for conservative investors.',
            performance: 12.5,
            riskLevel: 'Very Low',
            winRate: 85,
            avgTradeSize: 300,
            features: ['Capital Protection', 'Stop-Loss Systems', 'Portfolio Diversification', 'Risk Assessment'],
            fee: 8,
            algorithm: 'conservative'
        },
        {
            id: 'ai-4',
            name: 'Momentum Maverick',
            avatar: 'üöÄ',
            color: 'SOL',
            strategy: 'Trend Following & Breakout',
            description: 'Captures major market trends and breakouts. Excels in volatile market conditions.',
            performance: 32.1,
            riskLevel: 'High',
            winRate: 65,
            avgTradeSize: 100,
            features: ['Trend Analysis', 'Breakout Detection', 'Momentum Trading', 'Volatility Management'],
            fee: 15,
            algorithm: 'momentum'
        },
        {
            id: 'ai-5',
            name: 'Arbitrage Alpha',
            avatar: '‚öñÔ∏è',
            color: 'XRP',
            strategy: 'Cross-Exchange Arbitrage',
            description: 'Exploits price differences between different cryptocurrency exchanges for risk-free profits.',
            performance: 15.8,
            riskLevel: 'Very Low',
            winRate: 95,
            avgTradeSize: 500,
            features: ['Multi-Exchange', 'Instant Execution', 'Risk-Free Profits', 'Liquidity Analysis'],
            fee: 20,
            algorithm: 'cross_arbitrage'
        },
        {
            id: 'ai-6',
            name: 'Volatility Vortex',
            avatar: 'üå™Ô∏è',
            color: 'ADA',
            strategy: 'Volatility Harvesting',
            description: 'Thrives in high-volatility environments. Uses advanced options and derivatives strategies.',
            performance: 41.2,
            riskLevel: 'Very High',
            winRate: 58,
            avgTradeSize: 75,
            features: ['Options Trading', 'Volatility Analysis', 'Derivatives', 'Hedging Strategies'],
            fee: 25,
            algorithm: 'volatility'
        },
        {
            id: 'ai-7',
            name: 'Market Maker Pro',
            avatar: 'üèõÔ∏è',
            color: 'DOT',
            strategy: 'Liquidity Provision',
            description: 'Acts as a market maker, earning spreads and rebates while providing liquidity to exchanges.',
            performance: 9.7,
            riskLevel: 'Low',
            winRate: 90,
            avgTradeSize: 1000,
            features: ['Market Making', 'Spread Capture', 'Rebate Optimization', 'Liquidity Provision'],
            fee: 18,
            algorithm: 'market_making'
        }
    ];

    const DURATION_PRICES = {
        7: 10,    // 1 week
        30: 35,   // 1 month
        90: 90,   // 3 months
        180: 160, // 6 months
        365: 280  // 1 year
    };

    // Data Storage
    let users = [];
    let transactions = [];
    let pendingDeposits = [];
    let pendingWithdrawals = [];
    let currentUser = null;
    let cryptoPrices = {};
    let cryptoHoldings = {};
    let cryptoList = [];
    let currentCryptoModal = null;
    let currentDepositAmount = 0;
    let currentWithdrawAmount = 0;
    let mpesaAccessToken = null;
    let currentDeductionUser = null;
    let currentChart = null;
    let currentChartTimeframe = '1d';
    let userAiTraders = [];
    let selectedAiTrader = null;
    let currentInvestment = 0;
    let activeTradingIntervals = [];

    // Transaction counter for unique block numbers
    let transactionCounter = 0;

    // DOM Elements
    const authScreen = document.getElementById('auth-screen');
    const blockedUserScreen = document.getElementById('blocked-user-screen');
    const dashboardScreen = document.getElementById('dashboard-screen');
    const depositScreen = document.getElementById('deposit-screen');
    const paymentPendingScreen = document.getElementById('payment-pending-screen');
    const paymentSuccessScreen = document.getElementById('payment-success-screen');
    const sendMoneyScreen = document.getElementById('send-money-screen');
    const transactionsScreen = document.getElementById('transactions-screen');
    const cryptoTradingScreen = document.getElementById('crypto-trading-screen');
    const aiTraderScreen = document.getElementById('ai-trader-screen');
    const identityManagementScreen = document.getElementById('identity-management-screen');
    const adminPanel = document.getElementById('admin-panel');
    const loadingScreen = document.getElementById('loading-screen');
    const vcManagementScreen = document.getElementById('vc-management-screen'); // ADDED
    
    const loginTab = document.getElementById('login-tab');
    const registerTab = document.getElementById('register-tab');
    const loginForm = document.getElementById('login-form');
    const registerForm = document.getElementById('register-form');
    
    const loginBtn = document.getElementById('login-btn');
    const registerBtn = document.getElementById('register-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const backToLoginFromBlocked = document.getElementById('back-to-login-from-blocked');
    const didLoginOption = document.getElementById('did-login-option');
    
    const depositBtn = document.getElementById('deposit-btn');
    const sendMoneyBtn = document.getElementById('send-money-btn');
    const transactionsBtn = document.getElementById('transactions-btn');
    const aiTraderBtn = document.getElementById('ai-trader-btn');
    const cryptoBtn = document.getElementById('crypto-btn');
    const identityManagementBtn = document.getElementById('identity-management-btn');
    const adminBtn = document.getElementById('admin-btn');
    
    const backFromDeposit = document.getElementById('back-from-deposit');
    const backToDashboard = document.getElementById('back-to-dashboard');
    const backToDashboardFromPending = document.getElementById('back-to-dashboard-from-pending');
    
    const confirmSend = document.getElementById('confirm-send');
    const backFromSend = document.getElementById('back-from-send');
    
    const backFromTransactions = document.getElementById('back-from-transactions');
    const backFromCrypto = document.getElementById('back-from-crypto');
    const backFromAi = document.getElementById('back-from-ai');
    const backFromIdentity = document.getElementById('back-from-identity');
    const backFromAdmin = document.getElementById('back-from-admin');
    const backFromVc = document.getElementById('back-from-vc'); // ADDED
    
    const userBalance = document.getElementById('user-balance');
    const userPhone = document.getElementById('user-phone');
    const transactionsList = document.getElementById('transactions-list');
    const usersList = document.getElementById('users-list');
    const adminTransactionsList = document.getElementById('admin-transactions-list');
    const pendingDepositsList = document.getElementById('pending-deposits-list');
    const pendingWithdrawalsList = document.getElementById('pending-withdrawals-list');
    
    const sendAmount = document.getElementById('send-amount');
    const recipientPhone = document.getElementById('recipient-phone');
    const transactionFee = document.getElementById('transaction-fee');
    const totalDeducted = document.getElementById('total-deducted');
    
    const notification = document.getElementById('notification');
    const depositAmountInput = document.getElementById('deposit-amount');
    const withdrawAmountInput = document.getElementById('withdraw-amount');
    const paypalContainer = document.getElementById('paypal-container');
    const depositSuccessAmount = document.getElementById('deposit-success-amount');
    const depositMethod = document.getElementById('deposit-method');
    const pendingDepositAmount = document.getElementById('pending-deposit-amount');
    const pendingDepositMethod = document.getElementById('pending-deposit-method');
    const pendingType = document.getElementById('pending-type');
    const pendingType2 = document.getElementById('pending-type2');
    const successType = document.getElementById('success-type');

    // Deposit/Withdraw Tabs
    const depositTab = document.getElementById('deposit-tab');
    const withdrawTab = document.getElementById('withdraw-tab');
    const depositSection = document.getElementById('deposit-section');
    const withdrawSection = document.getElementById('withdraw-section');

    // Payment Method Tabs
    const paypalTab = document.getElementById('paypal-tab');
    const mpesaTab = document.getElementById('mpesa-tab');
    const paypalMethod = document.getElementById('paypal-method');
    const mpesaMethod = document.getElementById('mpesa-method');
    const paypalWithdrawMethod = document.getElementById('paypal-withdraw-method');
    const mpesaWithdrawMethod = document.getElementById('mpesa-withdraw-method');
    const mpesaPhoneInput = document.getElementById('mpesa-phone');
    const mpesaDepositBtn = document.getElementById('mpesa-deposit-btn');
    const mpesaStatus = document.getElementById('mpesa-status');
    const mpesaStatusText = document.getElementById('mpesa-status-text');
    const paypalWithdrawBtn = document.getElementById('paypal-withdraw-btn');
    const mpesaWithdrawBtn = document.getElementById('mpesa-withdraw-btn');
    const mpesaWithdrawStatus = document.getElementById('mpesa-withdraw-status');
    const mpesaWithdrawStatusText = document.getElementById('mpesa-withdraw-status-text');
    const paypalEmailInput = document.getElementById('paypal-email');
    const mpesaWithdrawPhoneInput = document.getElementById('mpesa-withdraw-phone');

    // Exchange Rate Elements
    const depositExchangeRate = document.getElementById('deposit-exchange-rate');
    const depositKshAmount = document.getElementById('deposit-ksh-amount');
    const withdrawExchangeRate = document.getElementById('withdraw-exchange-rate');
    const withdrawKshAmount = document.getElementById('withdraw-ksh-amount');

    // Crypto Trading Elements
    const cryptoListContainer = document.getElementById('crypto-list');
    const cryptoHoldingsList = document.getElementById('crypto-holdings-list');
    const cryptoSearch = document.getElementById('crypto-search');
    const portfolioTotal = document.getElementById('portfolio-total');
    const portfolioCash = document.getElementById('portfolio-cash');
    const portfolioCrypto = document.getElementById('portfolio-crypto');

    // AI Trader Elements
    const myAiTradersList = document.getElementById('my-ai-traders-list');
    const aiTraderList = document.getElementById('ai-trader-list');
    const aiSearch = document.getElementById('ai-search');
    const hireAiModal = document.getElementById('hire-ai-modal');
    const closeHireModal = document.getElementById('close-hire-modal');
    const cancelHire = document.getElementById('cancel-hire');
    const confirmHire = document.getElementById('confirm-hire');
    const investmentAmount = document.getElementById('investment-amount');
    const durationSelect = document.getElementById('duration');
    const displayInvestment = document.getElementById('display-investment');
    const displayFee = document.getElementById('display-fee');
    const displayTotal = document.getElementById('display-total');
    const activeAiCount = document.getElementById('active-ai-count');
    const totalAiInvestment = document.getElementById('total-ai-investment');
    const totalAiProfit = document.getElementById('total-ai-profit');
    const aiSuccessRate = document.getElementById('ai-success-rate');

    // Deduction Modal Elements
    const deductionModal = document.getElementById('deduction-modal');
    const closeDeductionModal = document.getElementById('close-deduction-modal');
    const cancelDeduction = document.getElementById('cancel-deduction');
    const confirmDeduction = document.getElementById('confirm-deduction');
    const deductionAmountInput = document.getElementById('deduction-amount');
    const deductionReasonInput = document.getElementById('deduction-reason');
    const deductionUserInfo = document.getElementById('deduction-user-info');

    // Identity Management Elements
    const didStatus = document.getElementById('did-status');
    const exportIdentityBtn = document.getElementById('export-identity-btn');
    const importIdentityBtn = document.getElementById('import-identity-btn');
    const backupDwnBtn = document.getElementById('backup-dwn-btn');
    const restoreDwnBtn = document.getElementById('restore-dwn-btn');
    const viewDidDocumentBtn = document.getElementById('view-did-document-btn');
    const syncDevicesBtn = document.getElementById('sync-devices-btn');
    const verifiableCredentialsBtn = document.getElementById('verifiable-credentials-btn'); // ADDED

    // DID Login Modal Elements
    const didLoginModal = document.getElementById('did-login-modal');
    const closeDidLogin = document.getElementById('close-did-login');
    const didLoginBtn = document.getElementById('did-login-btn');
    const traditionalLoginFallback = document.getElementById('traditional-login-fallback');
    const didPhoneInput = document.getElementById('did-phone');
    const didSignatureInput = document.getElementById('did-signature');

    // Export/Import Modal Elements
    const exportIdentityModal = document.getElementById('export-identity-modal');
    const closeExportIdentity = document.getElementById('close-export-identity');
    const confirmExport = document.getElementById('confirm-export');
    const cancelExport = document.getElementById('cancel-export');
    const exportPassword = document.getElementById('export-password');
    const confirmExportPassword = document.getElementById('confirm-export-password');

    const importIdentityModal = document.getElementById('import-identity-modal');
    const closeImportIdentity = document.getElementById('close-import-identity');
    const confirmImport = document.getElementById('confirm-import');
    const cancelImport = document.getElementById('cancel-import');
    const identityFile = document.getElementById('identity-file');
    const importPassword = document.getElementById('import-password');
    const importPhone = document.getElementById('import-phone');

    // DID Document Modal Elements
    const didDocumentModal = document.getElementById('did-document-modal');
    const closeDidDocument = document.getElementById('close-did-document');
    const didDocumentContent = document.getElementById('did-document-content');
    const copyDidDocument = document.getElementById('copy-did-document');
    const downloadDidDocument = document.getElementById('download-did-document');

    // Admin Panel Control Elements
    const showUsersBtn = document.getElementById('show-users-btn');
    const showTransactionsBtn = document.getElementById('show-transactions-btn');
    const showPendingBtn = document.getElementById('show-pending-btn');
    const showPendingWithdrawalsBtn = document.getElementById('show-pending-withdrawals-btn');
    const hideUsersBtn = document.getElementById('hide-users-btn');
    const hideTransactionsBtn = document.getElementById('hide-transactions-btn');
    const hidePendingBtn = document.getElementById('hide-pending-btn');
    const hidePendingWithdrawalsBtn = document.getElementById('hide-pending-withdrawals-btn');
    const userSearch = document.getElementById('user-search');
    const transactionSearch = document.getElementById('transaction-search');
    const usersSection = document.getElementById('users-section');
    const transactionsSection = document.getElementById('transactions-section');
    const pendingSection = document.getElementById('pending-section');
    const pendingWithdrawalsSection = document.getElementById('pending-withdrawals-section');

    // Firebase Database References
    const usersRef = ref(database, 'users');
    const transactionsRef = ref(database, 'transactions');
    const cryptoHoldingsRef = ref(database, 'cryptoHoldings');
    const pendingDepositsRef = ref(database, 'pendingDeposits');
    const pendingWithdrawalsRef = ref(database, 'pendingWithdrawals');
    const transactionCounterRef = ref(database, 'transactionCounter');
    const userAiTradersRef = ref(database, 'userAiTraders');

    // Event Listeners
    loginTab.addEventListener('click', () => {
        loginTab.classList.add('active');
        registerTab.classList.remove('active');
        loginForm.classList.remove('hidden');
        registerForm.classList.add('hidden');
    });

    registerTab.addEventListener('click', () => {
        registerTab.classList.add('active');
        loginTab.classList.remove('active');
        registerForm.classList.remove('hidden');
        loginForm.classList.add('hidden');
    });

    loginBtn.addEventListener('click', handleLogin);
    registerBtn.addEventListener('click', handleRegister);
    logoutBtn.addEventListener('click', handleLogout);
    backToLoginFromBlocked.addEventListener('click', () => showScreen(authScreen));
    didLoginOption.addEventListener('click', () => didLoginModal.classList.remove('hidden'));

    depositBtn.addEventListener('click', showDepositScreen);
    sendMoneyBtn.addEventListener('click', showSendMoneyScreen);
    transactionsBtn.addEventListener('click', showTransactionsScreen);
    aiTraderBtn.addEventListener('click', showAiTraderScreen);
    cryptoBtn.addEventListener('click', showCryptoTradingScreen);
    identityManagementBtn.addEventListener('click', showIdentityManagementScreen);
    adminBtn.addEventListener('click', showAdminPanel);

    backFromDeposit.addEventListener('click', () => showScreen(dashboardScreen));
    backToDashboard.addEventListener('click', () => showScreen(dashboardScreen));
    backToDashboardFromPending.addEventListener('click', () => showScreen(dashboardScreen));

    confirmSend.addEventListener('click', handleSendMoney);
    backFromSend.addEventListener('click', () => showScreen(dashboardScreen));

    backFromTransactions.addEventListener('click', () => showScreen(dashboardScreen));
    backFromCrypto.addEventListener('click', () => showScreen(dashboardScreen));
    backFromAi.addEventListener('click', () => showScreen(dashboardScreen));
    backFromIdentity.addEventListener('click', () => showScreen(dashboardScreen));
    backFromAdmin.addEventListener('click', () => showScreen(dashboardScreen));
    backFromVc.addEventListener('click', () => showScreen(identityManagementScreen)); // ADDED

    sendAmount.addEventListener('input', updateTransactionDetails);
    recipientPhone.addEventListener('input', updateTransactionDetails);
    depositAmountInput.addEventListener('input', handleDepositAmountChange);
    withdrawAmountInput.addEventListener('input', handleWithdrawAmountChange);

    // Deposit/Withdraw Tabs
    depositTab.addEventListener('click', () => switchDepositWithdrawTab('deposit'));
    withdrawTab.addEventListener('click', () => switchDepositWithdrawTab('withdraw'));
    
    // Payment Method Tabs
    paypalTab.addEventListener('click', () => switchPaymentMethod('paypal'));
    mpesaTab.addEventListener('click', () => switchPaymentMethod('mpesa'));
    
    // M-Pesa Deposit Button Event Listener
    mpesaDepositBtn.addEventListener('click', handleMpesaDeposit);
    
    // Withdrawal Button Event Listeners
    paypalWithdrawBtn.addEventListener('click', handlePayPalWithdrawal);
    mpesaWithdrawBtn.addEventListener('click', handleMpesaWithdrawal);

    // Crypto Trading Event Listeners
    cryptoSearch.addEventListener('input', filterCryptoList);

    // AI Trader Event Listeners
    aiSearch.addEventListener('input', filterAiTraders);
    closeHireModal.addEventListener('click', closeAiModals);
    cancelHire.addEventListener('click', closeAiModals);
    confirmHire.addEventListener('click', handleHireAi);
    investmentAmount.addEventListener('input', updateAiCostCalculation);
    durationSelect.addEventListener('change', updateAiCostCalculation);

    // Deduction Modal Event Listeners
    closeDeductionModal.addEventListener('click', closeDeductionModalFunc);
    cancelDeduction.addEventListener('click', closeDeductionModalFunc);
    confirmDeduction.addEventListener('click', handleDeduction);

    // Identity Management Event Listeners
    exportIdentityBtn.addEventListener('click', showExportIdentityModal);
    importIdentityBtn.addEventListener('click', showImportIdentityModal);
    backupDwnBtn.addEventListener('click', backupDWNData);
    restoreDwnBtn.addEventListener('click', restoreDWNData);
    viewDidDocumentBtn.addEventListener('click', showDIDDocument);
    syncDevicesBtn.addEventListener('click', syncDevices);
    verifiableCredentialsBtn.addEventListener('click', showVcManagementScreen); // ADDED

    // DID Login Event Listeners
    closeDidLogin.addEventListener('click', () => {
        didLoginModal.classList.add('hidden');
        showScreen(authScreen);
    });
    didLoginBtn.addEventListener('click', handleDIDLogin);
    traditionalLoginFallback.addEventListener('click', () => {
        didLoginModal.classList.add('hidden');
        showScreen(authScreen);
    });

    // Export/Import Event Listeners
    closeExportIdentity.addEventListener('click', () => exportIdentityModal.classList.add('hidden'));
    confirmExport.addEventListener('click', handleExportIdentity);
    cancelExport.addEventListener('click', () => exportIdentityModal.classList.add('hidden'));

    closeImportIdentity.addEventListener('click', () => importIdentityModal.classList.add('hidden'));
    confirmImport.addEventListener('click', handleImportIdentity);
    cancelImport.addEventListener('click', () => importIdentityModal.classList.add('hidden'));

    // DID Document Event Listeners
    closeDidDocument.addEventListener('click', () => didDocumentModal.classList.add('hidden'));
    copyDidDocument.addEventListener('click', copyDIDDocument);
    downloadDidDocument.addEventListener('click', downloadDIDDocument);

    // Admin Panel Event Listeners
    showUsersBtn.addEventListener('click', async () => {
        await displayAllUsers();
        usersSection.classList.remove('hidden');
        transactionsSection.classList.add('hidden');
        pendingSection.classList.add('hidden');
        pendingWithdrawalsSection.classList.add('hidden');
    });

    showTransactionsBtn.addEventListener('click', async () => {
        await displayAllTransactions();
        transactionsSection.classList.remove('hidden');
        usersSection.classList.add('hidden');
        pendingSection.classList.add('hidden');
        pendingWithdrawalsSection.classList.add('hidden');
    });

    showPendingBtn.addEventListener('click', async () => {
        await displayPendingDeposits();
        pendingSection.classList.remove('hidden');
        usersSection.classList.add('hidden');
        transactionsSection.classList.add('hidden');
        pendingWithdrawalsSection.classList.add('hidden');
    });

    showPendingWithdrawalsBtn.addEventListener('click', async () => {
        await displayPendingWithdrawals();
        pendingWithdrawalsSection.classList.remove('hidden');
        usersSection.classList.add('hidden');
        transactionsSection.classList.add('hidden');
        pendingSection.classList.add('hidden');
    });

    hideUsersBtn.addEventListener('click', () => {
        usersSection.classList.add('hidden');
    });

    hideTransactionsBtn.addEventListener('click', () => {
        transactionsSection.classList.add('hidden');
    });

    hidePendingBtn.addEventListener('click', () => {
        pendingSection.classList.add('hidden');
    });

    hidePendingWithdrawalsBtn.addEventListener('click', () => {
        pendingWithdrawalsSection.classList.add('hidden');
    });

    userSearch.addEventListener('input', filterUsers);
    transactionSearch.addEventListener('input', filterTransactions);

    // Copy contact info buttons
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('copy-btn')) {
            const text = e.target.dataset.text;
            navigator.clipboard.writeText(text).then(() => {
                showNotification('Contact info copied to clipboard', 'success');
            }).catch(err => {
                console.error('Failed to copy: ', err);
                showNotification('Failed to copy contact info', 'error');
            });
        }
    });

    // Global event listener for trade buttons
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('btn-trade')) {
            e.preventDefault();
            e.stopPropagation();
            
            const symbol = e.target.dataset.symbol;
            const action = e.target.dataset.action;
            
            // Check if user is logged in
            if (!currentUser) {
                showNotification('Please login first to trade cryptocurrencies', 'error');
                showScreen(authScreen);
                return;
            }
            
            // Check if it's an AI trader action
            if (e.target.dataset.aiId) {
                const aiId = e.target.dataset.aiId;
                if (action === 'hire') {
                    openHireAiModal(aiId);
                } else if (action === 'details') {
                    showAiTraderDetails(aiId);
                }
                return;
            }
            
            // Check if it's a cancel AI trader action
            if (e.target.dataset.traderId && action === 'cancel') {
                cancelAiTrader(e.target.dataset.traderId);
                return;
            }
            
            // Otherwise, it's a crypto trade
            openTradeModal(symbol, action);
        }
    });

    // VC Implementation for M-USD
    class VCIssuer {
        constructor() {
            this.issuerDID = null;
        }

        async issueKYCCredential(userDID, userData) {
            const vc = {
                "@context": [
                    "https://www.w3.org/2018/credentials/v1",
                    "https://m-usd.com/credentials/v1"
                ],
                id: `https://m-usd.com/credentials/${Date.now()}`,
                type: ["VerifiableCredential", "KYCIdentityCredential"],
                issuer: this.issuerDID,
                issuanceDate: new Date().toISOString(),
                credentialSubject: {
                    id: userDID,
                    phone: userData.phone,
                    kycLevel: "verified",
                    verifiedSince: userData.dateCreated,
                    status: "active"
                },
                credentialSchema: {
                    id: "https://m-usd.com/schemas/kyc-v1.json",
                    type: "JsonSchemaValidator2018"
                }
            };

            // Sign the VC
            vc.proof = await this.signCredential(vc);
            return vc;
        }

        async issueTradingCredential(userDID, tradingData) {
            const vc = {
                "@context": [
                    "https://www.w3.org/2018/credentials/v1",
                    "https://m-usd.com/credentials/trading/v1"
                ],
                id: `https://m-usd.com/credentials/trading/${Date.now()}`,
                type: ["VerifiableCredential", "CryptoTradingCredential"],
                issuer: this.issuerDID,
                issuanceDate: new Date().toISOString(),
                credentialSubject: {
                    id: userDID,
                    tradingLevel: tradingData.level,
                    limits: tradingData.limits,
                    verifiedPairs: tradingData.pairs,
                    riskAssessment: tradingData.riskLevel
                }
            };

            vc.proof = await this.signCredential(vc);
            return vc;
        }
        
        async signCredential(vc) {
            // Simulate signing for demo purposes
            return {
                type: "Ed25519Signature2020",
                created: new Date().toISOString(),
                proofPurpose: "assertionMethod",
                verificationMethod: `${this.issuerDID}#key-1`,
                proofValue: "simulated-signature-" + Date.now()
            };
        }
    }

    // VC Management System
    class VCManager {
        constructor() {
            this.vcIssuer = new VCIssuer();
            this.userVCs = new Map();
        }
        
        async initialize() {
            // Create issuer DID if not exists
            if (!this.vcIssuer.issuerDID) {
                this.vcIssuer.issuerDID = "did:musd:issuer:1a2b3c4d5e";
            }
            console.log('VC Manager initialized');
        }
        
        async issueKYCCredential(userDID, userData) {
            try {
                const vc = await this.vcIssuer.issueKYCCredential(userDID, userData);
                return {
                    success: true,
                    vc: vc
                };
            } catch (error) {
                return {
                    success: false,
                    error: error.message
                };
            }
        }
        
        async issueTradingCredential(userDID, tradingData) {
            try {
                const vc = await this.vcIssuer.issueTradingCredential(userDID, tradingData);
                return {
                    success: true,
                    vc: vc
                };
            } catch (error) {
                return {
                    success: false,
                    error: error.message
                };
            }
        }
        
        async storeVC(userDID, vc) {
            // Store in local cache
            if (!this.userVCs.has(userDID)) {
                this.userVCs.set(userDID, []);
            }
            this.userVCs.get(userDID).push(vc);
            
            // Store in DWN if available
            if (window.dwnManager && typeof dwnManager.storeVC === 'function') {
                try {
                    await dwnManager.storeVC(currentUser.phone, vc);
                } catch (error) {
                    console.error('Error storing VC in DWN:', error);
                }
            }
            
            return { success: true };
        }
        
        async getUserVCs(userDID) {
            // Check cache first
            if (this.userVCs.has(userDID)) {
                return this.userVCs.get(userDID);
            }
            return [];
        }
        
        async verifyVC(vc) {
            // Simple verification for demo purposes
            return {
                success: true,
                verified: vc.proof ? true : false,
                issuer: vc.issuer,
                issuanceDate: vc.issuanceDate,
                type: vc.type
            };
        }
        
        async exportVC(vc) {
            return {
                data: vc,
                format: 'application/vc+json',
                timestamp: new Date().toISOString()
            };
        }
    }

    // Initialize VC Manager
    const vcManager = new VCManager();

    // Firebase Data Functions
    async function loadUsers() {
        try {
            const snapshot = await get(usersRef);
            if (snapshot.exists()) {
                const usersData = snapshot.val();
                // Convert object to array
                users = Object.keys(usersData).map(key => ({
                    id: key,
                    ...usersData[key]
                }));
            } else {
                users = [];
            }
            return users;
        } catch (error) {
            console.error("Error loading users:", error);
            showNotification('Error loading users', 'error');
            return [];
        }
    }

    async function loadTransactions() {
        try {
            const snapshot = await get(transactionsRef);
            if (snapshot.exists()) {
                const transactionsData = snapshot.val();
                // Convert object to array
                transactions = Object.keys(transactionsData).map(key => ({
                    id: key,
                    ...transactionsData[key]
                }));
                // Sort by date descending
                transactions.sort((a, b) => new Date(b.date) - new Date(a.date));
            } else {
                transactions = [];
            }
            return transactions;
        } catch (error) {
            console.error("Error loading transactions:", error);
            showNotification('Error loading transactions', 'error');
            return [];
        }
    }

    async function loadPendingDeposits() {
        try {
            const snapshot = await get(pendingDepositsRef);
            if (snapshot.exists()) {
                const pendingData = snapshot.val();
                // Convert object to array
                pendingDeposits = Object.keys(pendingData).map(key => ({
                    id: key,
                    ...pendingData[key]
                }));
                // Sort by date descending
                pendingDeposits.sort((a, b) => new Date(b.date) - new Date(a.date));
            } else {
                pendingDeposits = [];
            }
            return pendingDeposits;
        } catch (error) {
            console.error("Error loading pending deposits:", error);
            showNotification('Error loading pending deposits', 'error');
            return [];
        }
    }

    async function loadPendingWithdrawals() {
        try {
            const snapshot = await get(pendingWithdrawalsRef);
            if (snapshot.exists()) {
                const pendingData = snapshot.val();
                // Convert object to array
                pendingWithdrawals = Object.keys(pendingData).map(key => ({
                    id: key,
                    ...pendingData[key]
                }));
                // Sort by date descending
                pendingWithdrawals.sort((a, b) => new Date(b.date) - new Date(a.date));
            } else {
                pendingWithdrawals = [];
            }
            return pendingWithdrawals;
        } catch (error) {
            console.error("Error loading pending withdrawals:", error);
            showNotification('Error loading pending withdrawals', 'error');
            return [];
        }
    }

    async function loadUserAiTraders() {
        try {
            const snapshot = await get(ref(database, `userAiTraders/${currentUser.id}`));
            if (snapshot.exists()) {
                const tradersData = snapshot.val();
                // Convert object to array and filter active traders
                userAiTraders = Object.keys(tradersData).map(key => ({
                    id: key,
                    ...tradersData[key]
                })).filter(trader => 
                    trader.status === 'active' && new Date(trader.expiresAt) > new Date()
                );
            } else {
                userAiTraders = [];
            }
        } catch (error) {
            console.error("Error loading user AI traders:", error);
            userAiTraders = [];
        }
    }

    async function loadTransactionCounter() {
        try {
            const snapshot = await get(transactionCounterRef);
            if (snapshot.exists()) {
                transactionCounter = snapshot.val();
            } else {
                transactionCounter = 1000; // Start from 1000
                await set(transactionCounterRef, transactionCounter);
            }
            return transactionCounter;
        } catch (error) {
            console.error("Error loading transaction counter:", error);
            transactionCounter = 1000;
            return transactionCounter;
        }
    }

    async function incrementTransactionCounter() {
        try {
            transactionCounter++;
            await set(transactionCounterRef, transactionCounter);
            return transactionCounter;
        } catch (error) {
            console.error("Error incrementing transaction counter:", error);
            return transactionCounter;
        }
    }

    async function saveUser(user) {
        try {
            if (user.id) {
                // Update existing user
                await update(ref(database, `users/${user.id}`), user);
            } else {
                // Add new user
                const newUserRef = push(usersRef);
                user.id = newUserRef.key;
                await set(newUserRef, user);
            }
            return user;
        } catch (error) {
            console.error("Error saving user:", error);
            showNotification('Error saving user data', 'error');
            return null;
        }
    }

    async function saveTransaction(transaction) {
        try {
            // Generate transaction hash and block number
            const blockNumber = await incrementTransactionCounter();
            const transactionHash = generateTransactionHash(transaction);
            
            transaction.blockNumber = blockNumber;
            transaction.transactionHash = transactionHash;
            
            const newTransactionRef = push(transactionsRef);
            transaction.id = newTransactionRef.key;
            await set(newTransactionRef, transaction);

            // Also store in DWN if user is logged in
            if (currentUser && window.dwnManager) {
                await dwnManager.storeTransaction(currentUser.phone, transaction);
            }
            
            return transaction;
        } catch (error) {
            console.error("Error saving transaction:", error);
            showNotification('Error saving transaction', 'error');
            return null;
        }
    }

    function generateTransactionHash(transaction) {
        // Generate a unique hash for the transaction
        const timestamp = new Date().getTime();
        const random = Math.random().toString(36).substring(2, 15);
        const data = `${transaction.from}-${transaction.to}-${transaction.amount}-${timestamp}-${random}`;
        
        // Simple hash function (in a real app, use a proper cryptographic hash)
        let hash = 0;
        for (let i = 0; i < data.length; i++) {
            const char = data.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        
        return `MUSD${Math.abs(hash).toString(16).toUpperCase().substring(0, 12)}`;
    }

    async function savePendingDeposit(deposit) {
        try {
            const newDepositRef = push(pendingDepositsRef);
            deposit.id = newDepositRef.key;
            await set(newDepositRef, deposit);
            return deposit;
        } catch (error) {
            console.error("Error saving pending deposit:", error);
            showNotification('Error saving pending deposit', 'error');
            return null;
        }
    }

    async function savePendingWithdrawal(withdrawal) {
        try {
            const newWithdrawalRef = push(pendingWithdrawalsRef);
            withdrawal.id = newWithdrawalRef.key;
            await set(newWithdrawalRef, withdrawal);
            return withdrawal;
        } catch (error) {
            console.error("Error saving pending withdrawal:", error);
            showNotification('Error saving pending withdrawal', 'error');
            return null;
        }
    }

    async function removePendingDeposit(depositId) {
        try {
            await remove(ref(database, `pendingDeposits/${depositId}`));
            return true;
        } catch (error) {
            console.error("Error removing pending deposit:", error);
            showNotification('Error removing pending deposit', 'error');
            return false;
        }
    }

    async function removePendingWithdrawal(withdrawalId) {
        try {
            await remove(ref(database, `pendingWithdrawals/${withdrawalId}`));
            return true;
        } catch (error) {
            console.error("Error removing pending withdrawal:", error);
            showNotification('Error removing pending withdrawal', 'error');
            return false;
        }
    }

    async function loadCryptoHoldings() {
        if (!currentUser) return {};
        
        try {
            const holdingsRef = ref(database, `cryptoHoldings/${currentUser.id}`);
            const snapshot = await get(holdingsRef);
            if (snapshot.exists()) {
                cryptoHoldings = snapshot.val();
            } else {
                cryptoHoldings = {};
            }
            return cryptoHoldings;
        } catch (error) {
            console.error("Error loading crypto holdings:", error);
            return {};
        }
    }

    async function saveCryptoHoldings(holdings) {
        if (!currentUser) return;
        
        try {
            const holdingsRef = ref(database, `cryptoHoldings/${currentUser.id}`);
            await set(holdingsRef, holdings);
        } catch (error) {
            console.error("Error saving crypto holdings:", error);
        }
    }

    // Enhanced DWN Manager with sync capabilities
    const enhancedDWNManager = {
        ...window.dwnManager,
        
        async syncProfileData(phone) {
            try {
                const profile = await this.getProfileData(phone);
                if (profile) {
                    await this.storeProfileData(phone, profile);
                    return { success: true, data: profile };
                }
                return { success: false, error: 'No profile data found' };
            } catch (error) {
                return { success: false, error: error.message };
            }
        },
        
        async syncTransactions(phone) {
            try {
                const transactions = await this.getTransactions(phone);
                if (transactions && transactions.length > 0) {
                    for (const transaction of transactions) {
                        await this.storeTransaction(phone, transaction);
                    }
                    return { success: true, count: transactions.length };
                }
                return { success: false, error: 'No transactions found' };
            } catch (error) {
                return { success: false, error: error.message };
            }
        },
        
        async syncCryptoData(phone) {
            try {
                const cryptoData = await this.getCryptoData(phone);
                if (cryptoData) {
                    await this.storeCryptoData(phone, cryptoData);
                    return { success: true, data: cryptoData };
                }
                return { success: false, error: 'No crypto data found' };
            } catch (error) {
                return { success: false, error: error.message };
            }
        },
        
        async syncAITraderData(phone) {
            try {
                const aiData = await this.getAITraderData(phone);
                if (aiData && aiData.length > 0) {
                    for (const trader of aiData) {
                        await this.storeAITraderData(phone, trader);
                    }
                    return { success: true, count: aiData.length };
                }
                return { success: false, error: 'No AI trader data found' };
            } catch (error) {
                return { success: false, error: error.message };
            }
        },
        
        async storeAITrade(phone, tradeData) {
            try {
                const record = await this.web5.dwn.records.create({
                    data: tradeData,
                    message: {
                        protocol: this.protocol,
                        protocolPath: 'aiTrade',
                        schema: 'ai-trade-schema',
                        dataFormat: 'application/json'
                    }
                });
                
                console.log('AI trade stored in DWN:', tradeData);
                return { success: true, record };
            } catch (error) {
                console.error('Error storing AI trade in DWN:', error);
                return { success: false, error: error.message };
            }
        },
        
        async storeVC(phone, vc) {
            try {
                const record = await this.web5.dwn.records.create({
                    data: vc,
                    message: {
                        protocol: this.protocol,
                        protocolPath: 'verifiableCredential',
                        schema: 'verifiable-credential-schema',
                        dataFormat: 'application/json'
                    }
                });
                
                console.log('VC stored in DWN:', vc);
                return { success: true, record };
            } catch (error) {
                console.error('Error storing VC in DWN:', error);
                return { success: false, error: error.message };
            }
        }
    };

    // Replace the global dwnManager with enhanced version
    window.dwnManager = enhancedDWNManager;

    // App Functions
    function showNotification(message, type = 'info') {
        notification.textContent = message;
        notification.className = `notification ${type} show`;
        
        setTimeout(() => {
            notification.classList.remove('show');
        }, 3000);
    }

    function showScreen(screen) {
        // Hide all screens
        const screens = [
            authScreen, blockedUserScreen, dashboardScreen, 
            depositScreen, paymentPendingScreen, paymentSuccessScreen, 
            sendMoneyScreen, transactionsScreen, cryptoTradingScreen, 
            aiTraderScreen, identityManagementScreen, adminPanel, loadingScreen,
            vcManagementScreen  // ADDED
        ];
        
        screens.forEach(screenElement => {
            if (screenElement) {
                screenElement.classList.add('hidden');
            }
        });
        
        // Show the requested screen
        screen.classList.remove('hidden');
        
        // Close any open modals
        closeCryptoModal();
        closeDeductionModalFunc();
        closeAiModals();
    }

    function showLoading() {
        authScreen.classList.add('hidden');
        blockedUserScreen.classList.add('hidden');
        dashboardScreen.classList.add('hidden');
        depositScreen.classList.add('hidden');
        paymentPendingScreen.classList.add('hidden');
        paymentSuccessScreen.classList.add('hidden');
        sendMoneyScreen.classList.add('hidden');
        transactionsScreen.classList.add('hidden');
        cryptoTradingScreen.classList.add('hidden');
        aiTraderScreen.classList.add('hidden');
        identityManagementScreen.classList.add('hidden');
        adminPanel.classList.add('hidden');
        vcManagementScreen.classList.add('hidden'); // ADDED
        loadingScreen.classList.remove('hidden');
    }

    function hideLoading() {
        loadingScreen.classList.add('hidden');
    }

    async function handleLogin() {
        const phone = document.getElementById('login-phone').value;
        const pin = document.getElementById('login-pin').value;
        
        if (!phone || !pin) {
            showNotification('Please enter phone number and PIN', 'error');
            return;
        }
        
        showLoading();
        
        try {
            await loadUsers();
            const user = users.find(u => u.phone === phone && u.pin === pin);
            
            if (!user) {
                showNotification('Invalid phone number or PIN', 'error');
                showScreen(authScreen);
                return;
            }
            
            if (user.isSuspended) {
                showNotification('Your account has been suspended. Contact support.', 'error');
                showScreen(authScreen);
                return;
            }
            
            if (user.isBlocked) {
                showScreen(blockedUserScreen);
                return;
            }
            
            currentUser = user;
            // Set the global app user
            window.app.setCurrentUser(user);
            
            // Load crypto data
            await loadCryptoPrices();
            cryptoHoldings = await loadCryptoHoldings();
            
            // Initialize demo holdings if none exist
            if (Object.keys(cryptoHoldings).length === 0) {
                cryptoHoldings = {
                    'BTC': { symbol: 'BTC', quantity: 0.00057226, name: 'Bitcoin' },
                    'ETH': { symbol: 'ETH', quantity: 0.10602469, name: 'Ethereum' }
                };
                await saveCryptoHoldings(cryptoHoldings);
            }
            
            // Load AI traders and start them
            await loadUserAiTraders();
            if (userAiTraders.length > 0) {
                startAllAITraders();
            }
            
            updateDashboard();
            showScreen(dashboardScreen);
            showNotification('Login successful!', 'success');
        } catch (error) {
            console.error("Login error:", error);
            showNotification('Login failed. Please try again.', 'error');
            showScreen(authScreen);
        }
    }

    async function handleRegister() {
        const phone = document.getElementById('register-phone').value;
        const pin = document.getElementById('register-pin').value;
        const confirmPin = document.getElementById('confirm-pin').value;
        
        if (!phone || !pin || !confirmPin) {
            showNotification('Please fill all fields', 'error');
            return;
        }
        
        if (pin !== confirmPin) {
            showNotification('PINs do not match', 'error');
            return;
        }
        
        if (pin.length !== 4) {
            showNotification('PIN must be 4 digits', 'error');
            return;
        }
        
        showLoading();
        
        try {
            await loadUsers();
            
            if (users.find(u => u.phone === phone)) {
                showNotification('Phone number already registered', 'error');
                showScreen(authScreen);
                return;
            }
            
            const newUser = {
                phone,
                pin,
                balance: 0,
                isAdmin: false,
                isSuspended: false,
                isBlocked: false,
                dateCreated: new Date().toISOString()
            };
            
            const savedUser = await saveUser(newUser);
            if (savedUser) {
                users.push(savedUser);
                
                // CREATE DID FOR THE NEW USER
                try {
                    await didManager.createDID(savedUser);
                    await dwnManager.initializeDWN(savedUser.phone, savedUser);
                    
                    showNotification('Registration successful! Decentralized identity created.', 'success');
                } catch (didError) {
                    console.error('DID creation failed:', didError);
                    showNotification('Registration successful, but identity creation failed. Please contact support.', 'warning');
                }
                
                loginTab.click();
                showScreen(authScreen);
                
                // Clear form
                document.getElementById('register-phone').value = '';
                document.getElementById('register-pin').value = '';
                document.getElementById('confirm-pin').value = '';
            }
        } catch (error) {
            console.error("Registration error:", error);
            showNotification('Registration failed. Please try again.', 'error');
            showScreen(authScreen);
        }
    }

    function handleLogout() {
        // Stop all AI trading intervals
        activeTradingIntervals.forEach(interval => clearInterval(interval));
        activeTradingIntervals = [];
        
        currentUser = null;
        window.app.setCurrentUser(null);
        showScreen(authScreen);
        showNotification('Logged out successfully', 'info');
    }

    function updateDashboard() {
        if (!currentUser) return;
        
        userBalance.textContent = `USD ${currentUser.balance.toFixed(2)}`;
        userPhone.textContent = currentUser.phone;
        
        // Only show admin button for admin users
        adminBtn.style.display = currentUser.isAdmin ? 'block' : 'none';
    }

    function showDepositScreen() {
        showScreen(depositScreen);
        depositAmountInput.value = '';
        withdrawAmountInput.value = '';
        paypalContainer.innerHTML = '';
        currentDepositAmount = 0;
        currentWithdrawAmount = 0;
        mpesaStatus.classList.add('hidden');
        mpesaWithdrawStatus.classList.add('hidden');
        
        // Reset to deposit tab by default
        switchDepositWithdrawTab('deposit');
    }

    function showSendMoneyScreen() {
        showScreen(sendMoneyScreen);
        document.getElementById('recipient-phone').value = '';
        document.getElementById('send-amount').value = '';
        updateTransactionDetails();
    }

    function updateTransactionDetails() {
        const amount = parseFloat(sendAmount.value) || 0;
        const fee = amount * 0.01; // 1% transaction fee
        const total = amount + fee;
        
        transactionFee.textContent = `USD ${fee.toFixed(2)}`;
        totalDeducted.textContent = `USD ${total.toFixed(2)}`;
    }

    async function handleSendMoney() {
        const recipient = document.getElementById('recipient-phone').value;
        const amount = parseFloat(document.getElementById('send-amount').value);
        
        if (!recipient || !amount || amount <= 0) {
            showNotification('Please enter valid recipient and amount', 'error');
            return;
        }
        
        if (recipient === currentUser.phone) {
            showNotification('Cannot send money to yourself', 'error');
            return;
        }
        
        showLoading();
        
        try {
            await loadUsers();
            const recipientUser = users.find(u => u.phone === recipient);
            
            if (!recipientUser) {
                showNotification('Recipient not found', 'error');
                showScreen(dashboardScreen);
                return;
            }
            
            if (recipientUser.isSuspended || recipientUser.isBlocked) {
                showNotification('Recipient account is not active', 'error');
                showScreen(dashboardScreen);
                return;
            }
            
            const fee = amount * 0.01; // 1% transaction fee
            const total = amount + fee;
            
            if (currentUser.balance < total) {
                showNotification('Insufficient balance', 'error');
                showScreen(dashboardScreen);
                return;
            }
            
            // Update balances
            currentUser.balance -= total;
            recipientUser.balance += amount;
            
            // Add fee to admin account
            const adminUser = users.find(u => u.isAdmin);
            if (adminUser) {
                adminUser.balance += fee;
                await saveUser(adminUser);
            }
            
            // Save updated users
            await saveUser(currentUser);
            await saveUser(recipientUser);
            
            // Record transaction for SENDER
            const senderTransaction = {
                from: currentUser.phone,
                to: recipient,
                amount: amount,
                fee: fee,
                type: 'send',
                date: new Date().toISOString(),
                userId: currentUser.id,
                netAmount: -total, // Negative amount for sender
                status: 'completed'
            };
            
            await saveTransaction(senderTransaction);
            
            // Record transaction for RECEIVER
            const receiverTransaction = {
                from: currentUser.phone,
                to: recipient,
                amount: amount,
                fee: 0, // No fee for receiver
                type: 'receive',
                date: new Date().toISOString(),
                userId: recipientUser.id,
                netAmount: amount, // Positive amount for receiver
                status: 'completed'
            };
            
            await saveTransaction(receiverTransaction);
            
            // Record fee transaction for admin
            if (adminUser && fee > 0) {
                const feeTransaction = {
                    from: `${currentUser.phone} (Fee)`,
                    to: 'ADMIN',
                    amount: fee,
                    fee: 0,
                    type: 'fee',
                    date: new Date().toISOString(),
                    userId: adminUser.id,
                    netAmount: fee,
                    status: 'completed'
                };
                
                await saveTransaction(feeTransaction);
            }
            
            // Reload data
            await loadUsers();
            await loadTransactions();
            
            // Update current user reference
            currentUser = users.find(u => u.id === currentUser.id);
            window.app.setCurrentUser(currentUser);
            
            updateDashboard();
            showScreen(dashboardScreen);
            showNotification(`Sent USD ${amount.toFixed(2)} to ${recipient}`, 'success');
        } catch (error) {
            console.error("Send money error:", error);
            showNotification('Transaction failed. Please try again.', 'error');
            showScreen(dashboardScreen);
        }
    }

    async function showTransactionsScreen() {
        showScreen(transactionsScreen);
        await displayUserTransactions();
    }

    async function displayUserTransactions() {
        if (!currentUser) return;
        
        await loadTransactions();
        
        const userTransactions = transactions.filter(
            t => t.userId === currentUser.id
        );
        
        transactionsList.innerHTML = '';
        
        if (userTransactions.length === 0) {
            transactionsList.innerHTML = '<p class="no-transactions">No transactions found</p>';
            return;
        }
        
        userTransactions.forEach(transaction => {
            const transactionEl = document.createElement('div');
            transactionEl.className = 'transaction-item';
            
            // Determine transaction type and styling
            let typeText, amountClass, amountPrefix, description;
            
            if (transaction.type === 'send') {
                typeText = 'Sent Money';
                amountClass = 'transaction-negative';
                amountPrefix = '-';
                description = `To: ${transaction.to}`;
            } else if (transaction.type === 'receive') {
                typeText = 'Received Money';
                amountClass = 'transaction-positive';
                amountPrefix = '+';
                description = `From: ${transaction.from}`;
            } else if (transaction.type === 'deposit') {
                typeText = 'Deposit';
                amountClass = 'transaction-positive';
                amountPrefix = '+';
                description = `Method: ${transaction.method || 'Unknown'}`;
            } else if (transaction.type === 'withdrawal') {
                typeText = 'Withdrawal';
                amountClass = 'transaction-negative';
                amountPrefix = '-';
                description = `Method: ${transaction.method || 'Unknown'}`;
            } else if (transaction.type === 'crypto_buy') {
                typeText = 'Crypto Buy';
                amountClass = 'transaction-negative';
                amountPrefix = '-';
                description = `Bought ${transaction.quantity || 0} ${transaction.symbol || ''}`;
            } else if (transaction.type === 'crypto_sell') {
                typeText = 'Crypto Sell';
                amountClass = 'transaction-positive';
                amountPrefix = '+';
                description = `Sold ${transaction.quantity || 0} ${transaction.symbol || ''}`;
            } else if (transaction.type === 'fee') {
                typeText = 'Transaction Fee';
                amountClass = 'transaction-negative';
                amountPrefix = '-';
                description = `Fee for transaction`;
            } else if (transaction.type === 'deduction') {
                typeText = 'Funds Deduction';
                amountClass = 'transaction-negative';
                amountPrefix = '-';
                description = `Admin deduction: ${transaction.reason || ''}`;
            } else if (transaction.type === 'recovery') {
                typeText = 'Funds Recovery';
                amountClass = 'transaction-negative';
                amountPrefix = '-';
                description = `Admin recovery`;
            } else if (transaction.type === 'ai_investment') {
                typeText = 'AI Trader Investment';
                amountClass = 'transaction-negative';
                amountPrefix = '-';
                description = `AI Trader: ${transaction.to || ''}`;
            } else if (transaction.type === 'ai_trader_fee') {
                typeText = 'AI Trader Fee';
                amountClass = 'transaction-negative';
                amountPrefix = '-';
                description = `AI Trader Service Fee`;
            } else if (transaction.type === 'ai_refund') {
                typeText = 'AI Trader Refund';
                amountClass = 'transaction-positive';
                amountPrefix = '+';
                description = `AI Trader Cancellation`;
            } else {
                typeText = transaction.type || 'Transaction';
                amountClass = transaction.netAmount >= 0 ? 'transaction-positive' : 'transaction-negative';
                amountPrefix = transaction.netAmount >= 0 ? '+' : '-';
                description = `From: ${transaction.from} ‚Üí To: ${transaction.to}`;
            }
            
            const displayAmount = Math.abs(transaction.netAmount !== undefined ? transaction.netAmount : transaction.amount);
            
            // Get status badge
            let statusBadge = '';
            if (transaction.status) {
                const statusClass = transaction.status === 'completed' ? 'status-completed' : 
                                  transaction.status === 'rejected' ? 'status-rejected' : 
                                  transaction.status === 'pending' ? 'status-pending' : 'status-pending';
                statusBadge = `<span class="status-badge ${statusClass}">${transaction.status}</span>`;
            }
            
            transactionEl.innerHTML = `
                <div class="transaction-details">
                    <div class="transaction-type">${typeText} ${statusBadge}</div>
                    <div class="transaction-date">${new Date(transaction.date).toLocaleString()}</div>
                    <div class="transaction-parties">${description}</div>
                    ${transaction.transactionHash ? `<div class="transaction-hash">Hash: ${transaction.transactionHash}</div>` : ''}
                    ${transaction.blockNumber ? `<div class="block-number">Block: ${transaction.blockNumber}</div>` : ''}
                    ${transaction.fee > 0 ? `<div class="transaction-fee">Fee: USD ${transaction.fee.toFixed(2)}</div>` : ''}
                    ${transaction.method ? `<div class="transaction-method">Method: ${transaction.method}</div>` : ''}
                    ${transaction.reason ? `<div class="transaction-reason">Reason: ${transaction.reason}</div>` : ''}
                </div>
                <div class="transaction-amount ${amountClass}">
                    ${amountPrefix}USD ${displayAmount.toFixed(2)}
                </div>
            `;
            
            transactionsList.appendChild(transactionEl);
        });
    }

    async function showCryptoTradingScreen() {
        // Check if user is logged in
        if (!currentUser) {
            showNotification('Please login first to access crypto trading', 'error');
            showScreen(authScreen);
            return;
        }

        showScreen(cryptoTradingScreen);
        
        // Load crypto data if not already loaded
        if (Object.keys(cryptoPrices).length === 0) {
            await loadCryptoPrices();
        }
        
        // Update portfolio and displays
        updatePortfolioDisplay();
        displayCryptoList();
        displayCryptoHoldings();
    }

    // Crypto Trading Functions
    async function loadCryptoPrices() {
        try {
            // Using CoinGecko API to get top 20 cryptocurrencies
            console.log('Loading real cryptocurrency prices...');
            const response = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=20&page=1&sparkline=false&price_change_percentage=24h');
            
            if (!response.ok) {
                throw new Error(`API request failed with status ${response.status}`);
            }
            
            const data = await response.json();
            
            cryptoList = data;
            cryptoPrices = {};
            
            data.forEach(crypto => {
                cryptoPrices[crypto.symbol.toUpperCase()] = {
                    id: crypto.id,
                    name: crypto.name,
                    symbol: crypto.symbol.toUpperCase(),
                    price: crypto.current_price,
                    change24h: crypto.price_change_percentage_24h,
                    marketCap: crypto.market_cap,
                    icon: crypto.image
                };
            });
            
            console.log('Successfully loaded real crypto prices');
            return cryptoPrices;
        } catch (error) {
            console.error("Error loading crypto prices:", error);
            // For crypto prices, we can use a more robust fallback since trading depends on it
            showNotification('Using demo crypto data due to API limit', 'info');
            cryptoPrices = getMockCryptoPrices();
            cryptoList = Object.values(cryptoPrices);
            return cryptoPrices;
        }
    }

    function getMockCryptoPrices() {
        return {
            'BTC': { id: 'bitcoin', name: 'Bitcoin', symbol: 'BTC', price: 87026.00, change24h: -3.41, marketCap: 880000000000, icon: '‚Çø' },
            'ETH': { id: 'ethereum', name: 'Ethereum', symbol: 'ETH', price: 2847.50, change24h: -4.25, marketCap: 385000000000, icon: 'Œû' },
            'BNB': { id: 'binancecoin', name: 'Binance Coin', symbol: 'BNB', price: 580, change24h: 0.5, marketCap: 89000000000, icon: '‚ìë' },
            'SOL': { id: 'solana', name: 'Solana', symbol: 'SOL', price: 120, change24h: 5.2, marketCap: 52000000000, icon: '‚óé' },
            'XRP': { id: 'ripple', name: 'XRP', symbol: 'XRP', price: 0.62, change24h: -1.2, marketCap: 34000000000, icon: '‚úï' },
            'ADA': { id: 'cardano', name: 'Cardano', symbol: 'ADA', price: 0.48, change24h: 0.8, marketCap: 17000000000, icon: 'A' },
            'DOGE': { id: 'dogecoin', name: 'Dogecoin', symbol: 'DOGE', price: 0.12, change24h: 3.5, marketCap: 17000000000, icon: '√ê' },
            'DOT': { id: 'polkadot', name: 'Polkadot', symbol: 'DOT', price: 7.2, change24h: -0.5, marketCap: 9200000000, icon: '‚óè' },
            'AVAX': { id: 'avalanche-2', name: 'Avalanche', symbol: 'AVAX', price: 38, change24h: 2.1, marketCap: 15000000000, icon: '‚õ∞Ô∏è' },
            'LINK': { id: 'chainlink', name: 'Chainlink', symbol: 'LINK', price: 18, change24h: 1.2, marketCap: 10500000000, icon: 'üîó' }
        };
    }

    function calculatePortfolioValue() {
        if (!currentUser) return { total: 0, cash: 0, crypto: 0 };
        
        const cash = currentUser.balance || 0;
        let cryptoValue = 0;
        
        Object.keys(cryptoHoldings).forEach(symbol => {
            const holding = cryptoHoldings[symbol];
            const price = cryptoPrices[symbol]?.price || 0;
            cryptoValue += holding.quantity * price;
        });
        
        const total = cash + cryptoValue;
        
        return {
            total: total,
            cash: cash,
            crypto: cryptoValue
        };
    }

    function updatePortfolioDisplay() {
        const portfolio = calculatePortfolioValue();
        
        portfolioTotal.textContent = `USD ${portfolio.total.toFixed(2)}`;
        portfolioCash.textContent = `USD ${portfolio.cash.toFixed(2)}`;
        portfolioCrypto.textContent = `USD ${portfolio.crypto.toFixed(2)}`;
    }

    function displayCryptoList() {
        if (!cryptoListContainer) return;
        
        cryptoListContainer.innerHTML = '';
        
        if (cryptoList.length === 0) {
            cryptoListContainer.innerHTML = '<p class="no-crypto">No cryptocurrencies found</p>';
            return;
        }
        
        cryptoList.forEach(crypto => {
            const cryptoEl = document.createElement('div');
            cryptoEl.className = 'crypto-item';
            
            const changeClass = crypto.price_change_percentage_24h >= 0 ? 'positive' : 'negative';
            const changeIcon = crypto.price_change_percentage_24h >= 0 ? '‚Üó' : '‚Üò';
            const symbol = crypto.symbol.toUpperCase();
            
            cryptoEl.innerHTML = `
                <div class="crypto-info">
                    <div class="crypto-icon ${symbol}">
                        ${symbol === 'BTC' ? '‚Çø' : 
                          symbol === 'ETH' ? 'Œû' : 
                          symbol === 'BNB' ? '‚ìë' : 
                          symbol === 'SOL' ? '‚óé' : 
                          symbol === 'XRP' ? '‚úï' : 
                          symbol === 'ADA' ? 'A' : 
                          symbol === 'DOGE' ? '√ê' : 
                          symbol === 'DOT' ? '‚óè' : 
                          symbol === 'AVAX' ? '‚õ∞Ô∏è' : 
                          symbol === 'LINK' ? 'üîó' : '‚Çø'}
                    </div>
                    <div class="crypto-details">
                        <div class="crypto-name">${crypto.name}</div>
                        <div class="crypto-symbol">${symbol}</div>
                    </div>
                </div>
                <div class="crypto-price">
                    <div class="crypto-current">$${crypto.current_price?.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 8}) || '0.00'}</div>
                    <div class="crypto-change ${changeClass}">
                        ${changeIcon} ${Math.abs(crypto.price_change_percentage_24h || 0).toFixed(2)}%
                    </div>
                </div>
                <div class="crypto-actions">
                    <button class="btn-trade" data-symbol="${symbol}" data-action="buy">Buy</button>
                    <button class="btn-trade" data-symbol="${symbol}" data-action="sell">Sell</button>
                </div>
            `;
            
            cryptoListContainer.appendChild(cryptoEl);
        });
    }

    function displayCryptoHoldings() {
        if (!cryptoHoldingsList) return;
        
        cryptoHoldingsList.innerHTML = '';
        
        const holdings = Object.values(cryptoHoldings);
        
        if (holdings.length === 0) {
            cryptoHoldingsList.innerHTML = '<p class="no-holdings">No crypto holdings</p>';
            return;
        }
        
        holdings.forEach(holding => {
            const crypto = cryptoPrices[holding.symbol];
            if (!crypto) return;
            
            const value = holding.quantity * crypto.price;
            const changeClass = crypto.change24h >= 0 ? 'positive' : 'negative';
            const changeIcon = crypto.change24h >= 0 ? '‚Üó' : '‚Üò';
            const symbol = holding.symbol;
            
            const holdingEl = document.createElement('div');
            holdingEl.className = 'holding-item';
            
            holdingEl.innerHTML = `
                <div class="holding-info">
                    <div class="holding-icon ${symbol}">
                        ${symbol === 'BTC' ? '‚Çø' : 
                          symbol === 'ETH' ? 'Œû' : 
                          symbol === 'BNB' ? '‚ìë' : 
                          symbol === 'SOL' ? '‚óé' : 
                          symbol === 'XRP' ? '‚úï' : 
                          symbol === 'ADA' ? 'A' : 
                          symbol === 'DOGE' ? '√ê' : 
                          symbol === 'DOT' ? '‚óè' : 
                          symbol === 'AVAX' ? '‚õ∞Ô∏è' : 
                          symbol === 'LINK' ? 'üîó' : '‚Çø'}
                    </div>
                    <div class="holding-details">
                        <div class="holding-name">${crypto.name}</div>
                        <div class="holding-symbol">${symbol}</div>
                    </div>
                </div>
                <div class="holding-quantity">
                    <div class="holding-amount">${holding.quantity.toFixed(8)}</div>
                    <div class="holding-value">$${value.toFixed(2)}</div>
                </div>
                <div class="holding-change ${changeClass}">
                    ${changeIcon} ${Math.abs(crypto.change24h || 0).toFixed(2)}%
                </div>
            `;
            
            cryptoHoldingsList.appendChild(holdingEl);
        });
    }

    function filterCryptoList() {
        const searchTerm = cryptoSearch.value.toLowerCase();
        
        if (!searchTerm) {
            displayCryptoList();
            return;
        }
        
        const filteredCrypto = cryptoList.filter(crypto => 
            crypto.name.toLowerCase().includes(searchTerm) || 
            crypto.symbol.toLowerCase().includes(searchTerm)
        );
        
        cryptoListContainer.innerHTML = '';
        
        if (filteredCrypto.length === 0) {
            cryptoListContainer.innerHTML = '<p class="no-crypto">No cryptocurrencies found</p>';
            return;
        }
        
        filteredCrypto.forEach(crypto => {
            const cryptoEl = document.createElement('div');
            cryptoEl.className = 'crypto-item';
            
            const changeClass = crypto.price_change_percentage_24h >= 0 ? 'positive' : 'negative';
            const changeIcon = crypto.price_change_percentage_24h >= 0 ? '‚Üó' : '‚Üò';
            const symbol = crypto.symbol.toUpperCase();
            
            cryptoEl.innerHTML = `
                <div class="crypto-info">
                    <div class="crypto-icon ${symbol}">
                        ${symbol === 'BTC' ? '‚Çø' : 
                          symbol === 'ETH' ? 'Œû' : 
                          symbol === 'BNB' ? '‚ìë' : 
                          symbol === 'SOL' ? '‚óé' : 
                          symbol === 'XRP' ? '‚úï' : 
                          symbol === 'ADA' ? 'A' : 
                          symbol === 'DOGE' ? '√ê' : 
                          symbol === 'DOT' ? '‚óè' : 
                          symbol === 'AVAX' ? '‚õ∞Ô∏è' : 
                          symbol === 'LINK' ? 'üîó' : '‚Çø'}
                    </div>
                    <div class="crypto-details">
                        <div class="crypto-name">${crypto.name}</div>
                        <div class="crypto-symbol">${symbol}</div>
                    </div>
                </div>
                <div class="crypto-price">
                    <div class="crypto-current">$${crypto.current_price?.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 8}) || '0.00'}</div>
                    <div class="crypto-change ${changeClass}">
                        ${changeIcon} ${Math.abs(crypto.price_change_percentage_24h || 0).toFixed(2)}%
                    </div>
                </div>
                <div class="crypto-actions">
                    <button class="btn-trade" data-symbol="${symbol}" data-action="buy">Buy</button>
                    <button class="btn-trade" data-symbol="${symbol}" data-action="sell">Sell</button>
                </div>
            `;
            
            cryptoListContainer.appendChild(cryptoEl);
        });
    }

    function openTradeModal(symbol, action) {
        // Check if user is logged in
        if (!currentUser) {
            showNotification('Please login first', 'error');
            return;
        }

        const crypto = cryptoPrices[symbol];
        if (!crypto) {
            showNotification('Cryptocurrency not found', 'error');
            return;
        }
        
        // Remove any existing modal first
        closeCryptoModal();
        
        // Create modal dynamically
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.id = 'crypto-modal';
        
        modal.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="crypto-modal-title">${action === 'buy' ? 'Buy' : 'Sell'} ${crypto.name}</h2>
                    <span class="close-modal" id="close-crypto-modal">&times;</span>
                </div>
                <div class="modal-body">
                    <div class="crypto-info">
                        <div class="crypto-icon ${symbol}" id="crypto-modal-icon">
                            ${symbol === 'BTC' ? '‚Çø' : 
                              symbol === 'ETH' ? 'Œû' : 
                              symbol === 'BNB' ? '‚ìë' : 
                              symbol === 'SOL' ? '‚óé' : 
                              symbol === 'XRP' ? '‚úï' : 
                              symbol === 'ADA' ? 'A' : 
                              symbol === 'DOGE' ? '√ê' : 
                              symbol === 'DOT' ? '‚óè' : 
                              symbol === 'AVAX' ? '‚õ∞Ô∏è' : 
                              symbol === 'LINK' ? 'üîó' : '‚Çø'}
                        </div>
                        <div class="crypto-details">
                            <h3 id="crypto-modal-name">${crypto.name}</h3>
                            <p id="crypto-modal-symbol">${crypto.symbol}</p>
                            <p id="crypto-modal-price">Price: $${crypto.price.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 8})}</p>
                        </div>
                    </div>
                    
                    <!-- NEW: Chart View -->
                    <div class="chart-container">
                        <div class="chart-header">
                            <div class="chart-title">Price Chart</div>
                            <div class="chart-timeframe">
                                <button class="timeframe-btn ${currentChartTimeframe === '1h' ? 'active' : ''}" data-timeframe="1h">1H</button>
                                <button class="timeframe-btn ${currentChartTimeframe === '1d' ? 'active' : ''}" data-timeframe="1d">1D</button>
                                <button class="timeframe-btn ${currentChartTimeframe === '7d' ? 'active' : ''}" data-timeframe="7d">7D</button>
                                <button class="timeframe-btn ${currentChartTimeframe === '1m' ? 'active' : ''}" data-timeframe="1m">1M</button>
                                <button class="timeframe-btn ${currentChartTimeframe === '1y' ? 'active' : ''}" data-timeframe="1y">1Y</button>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="crypto-chart"></canvas>
                        </div>
                    </div>
                    
                    <div class="trade-tabs">
                        <div class="trade-tab ${action === 'buy' ? 'active' : ''}" id="buy-tab">Buy</div>
                        <div class="trade-tab ${action === 'sell' ? 'active' : ''}" id="sell-tab">Sell</div>
                    </div>
                    
                    <div id="buy-form" ${action === 'buy' ? '' : 'class="hidden"'}>
                        <div class="form-group">
                            <label for="buy-amount">Amount in USD</label>
                            <input type="number" id="buy-amount" class="form-control" placeholder="Enter USD amount" min="1" step="0.01">
                        </div>
                        <div class="form-group">
                            <label for="buy-quantity">Quantity</label>
                            <input type="number" id="buy-quantity" class="form-control" placeholder="0.00000000" step="0.00000001" readonly>
                        </div>
                        <div class="form-group">
                            <p>Available Balance: <span id="available-balance">USD ${currentUser.balance.toFixed(2)}</span></p>
                            <p>Fee (0.5%): <span id="buy-fee">USD 0.00</span></p>
                            <p>Total Cost: <span id="buy-total">USD 0.00</span></p>
                        </div>
                        <button class="btn btn-primary" id="confirm-buy">Buy</button>
                    </div>
                    
                    <div id="sell-form" ${action === 'sell' ? '' : 'class="hidden"'}>
                        <div class="form-group">
                            <label for="sell-quantity">Quantity to Sell</label>
                            <input type="number" id="sell-quantity" class="form-control" placeholder="0.00000000" min="0" step="0.00000001">
                        </div>
                        <div class="form-group">
                            <label for="sell-amount">Amount in USD</label>
                            <input type="number" id="sell-amount" class="form-control" placeholder="0.00" readonly>
                        </div>
                        <div class="form-group">
                            <p>Available: <span id="available-crypto">${cryptoHoldings[symbol] ? cryptoHoldings[symbol].quantity.toFixed(8) : '0.00000000'}</span></p>
                            <p>Fee (0.5%): <span id="sell-fee">USD 0.00</span></p>
                            <p>Total Proceeds: <span id="sell-total">USD 0.00</span></p>
                        </div>
                        <button class="btn btn-danger" id="confirm-sell">Sell</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        currentCryptoModal = modal;
        
        // Add event listeners
        document.getElementById('close-crypto-modal').addEventListener('click', closeCryptoModal);
        document.getElementById('buy-tab').addEventListener('click', () => switchTradeTab('buy'));
        document.getElementById('sell-tab').addEventListener('click', () => switchTradeTab('sell'));
        
        // NEW: Chart timeframe buttons
        document.querySelectorAll('.timeframe-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                updateChartTimeframe(e.target.dataset.timeframe);
            });
        });
        
        const buyAmountInput = document.getElementById('buy-amount');
        const sellQuantityInput = document.getElementById('sell-quantity');
        
        if (buyAmountInput) {
            buyAmountInput.addEventListener('input', updateBuyDetails);
        }
        if (sellQuantityInput) {
            sellQuantityInput.addEventListener('input', updateSellDetails);
        }
        
        document.getElementById('confirm-buy').addEventListener('click', handleBuyCrypto);
        document.getElementById('confirm-sell').addEventListener('click', handleSellCrypto);
        
        // Store current trading symbol
        modal.dataset.tradingSymbol = symbol;
        
        // Render the chart
        renderChart('crypto-chart', symbol, currentChartTimeframe);
    }

    function closeCryptoModal() {
        if (currentCryptoModal) {
            currentCryptoModal.remove();
            currentCryptoModal = null;
        }
        if (currentChart) {
            currentChart.destroy();
            currentChart = null;
        }
    }

    function switchTradeTab(tab) {
        if (!currentCryptoModal) return;
        
        const buyTab = document.getElementById('buy-tab');
        const sellTab = document.getElementById('sell-tab');
        const buyForm = document.getElementById('buy-form');
        const sellForm = document.getElementById('sell-form');
        
        if (tab === 'buy') {
            buyTab.classList.add('active');
            sellTab.classList.remove('active');
            buyForm.classList.remove('hidden');
            sellForm.classList.add('hidden');
        } else {
            sellTab.classList.add('active');
            buyTab.classList.remove('active');
            sellForm.classList.remove('hidden');
            buyForm.classList.add('hidden');
        }
    }

    function updateBuyDetails() {
        if (!currentCryptoModal) return;
        
        const amount = parseFloat(document.getElementById('buy-amount')?.value) || 0;
        const symbol = currentCryptoModal.dataset.tradingSymbol;
        const crypto = cryptoPrices[symbol];
        
        if (!crypto || amount <= 0) {
            document.getElementById('buy-quantity').value = '';
            document.getElementById('buy-fee').textContent = 'USD 0.00';
            document.getElementById('buy-total').textContent = 'USD 0.00';
            return;
        }
        
        const fee = amount * 0.005; // 0.5% trading fee
        const total = amount + fee;
        const quantity = amount / crypto.price;
        
        document.getElementById('buy-quantity').value = quantity.toFixed(8);
        document.getElementById('buy-fee').textContent = `USD ${fee.toFixed(2)}`;
        document.getElementById('buy-total').textContent = `USD ${total.toFixed(2)}`;
    }

    function updateSellDetails() {
        if (!currentCryptoModal) return;
        
        const quantity = parseFloat(document.getElementById('sell-quantity')?.value) || 0;
        const symbol = currentCryptoModal.dataset.tradingSymbol;
        const crypto = cryptoPrices[symbol];
        
        if (!crypto || quantity <= 0) {
            document.getElementById('sell-amount').value = '';
            document.getElementById('sell-fee').textContent = 'USD 0.00';
            document.getElementById('sell-total').textContent = `USD 0.00`;
            return;
        }
        
        const amount = quantity * crypto.price;
        const fee = amount * 0.005; // 0.5% trading fee
        const total = amount - fee;
        
        document.getElementById('sell-amount').value = total.toFixed(2);
        document.getElementById('sell-fee').textContent = `USD ${fee.toFixed(2)}`;
        document.getElementById('sell-total').textContent = `USD ${total.toFixed(2)}`;
    }

    async function handleBuyCrypto() {
        if (!currentUser) {
            showNotification('Please login first', 'error');
            return;
        }

        if (!currentCryptoModal) return;
        
        const amount = parseFloat(document.getElementById('buy-amount')?.value) || 0;
        const symbol = currentCryptoModal.dataset.tradingSymbol;
        const crypto = cryptoPrices[symbol];
        
        if (!amount || amount <= 0) {
            showNotification('Please enter a valid amount', 'error');
            return;
        }
        
        const fee = amount * 0.005;
        const total = amount + fee;
        
        if (currentUser.balance < total) {
            showNotification('Insufficient balance', 'error');
            return;
        }
        
        showLoading();
        
        try {
            // Update user balance
            currentUser.balance -= total;
            
            // Update crypto holdings
            const quantity = amount / crypto.price;
            if (cryptoHoldings[symbol]) {
                cryptoHoldings[symbol].quantity += quantity;
            } else {
                cryptoHoldings[symbol] = {
                    symbol: symbol,
                    quantity: quantity,
                    name: crypto.name
                };
            }
            
            // Save updated user and holdings
            await saveUser(currentUser);
            await saveCryptoHoldings(cryptoHoldings);
            
            // Record transaction
            const transaction = {
                from: 'USD',
                to: symbol,
                amount: amount,
                fee: fee,
                type: 'crypto_buy',
                symbol: symbol,
                quantity: quantity,
                price: crypto.price,
                date: new Date().toISOString(),
                userId: currentUser.id
            };
            
            await saveTransaction(transaction);
            
            // STORE IN DWN
            if (window.dwnManager) {
                await dwnManager.storeTradingData(currentUser.phone, {
                    symbol: symbol,
                    action: 'buy',
                    amount: amount,
                    quantity: quantity,
                    price: crypto.price,
                    timestamp: new Date().toISOString(),
                    transactionId: transaction.id
                });
            }
            
            // Reload data
            await loadUsers();
            
            // Update current user reference
            currentUser = users.find(u => u.id === currentUser.id);
            window.app.setCurrentUser(currentUser);
            
            // Update displays
            updateDashboard();
            updatePortfolioDisplay();
            displayCryptoHoldings();
            
            // Close modal and show success
            closeCryptoModal();
            showScreen(cryptoTradingScreen);
            showNotification(`Bought ${quantity.toFixed(8)} ${symbol} for $${amount.toFixed(2)}`, 'success');
        } catch (error) {
            console.error("Buy crypto error:", error);
            showNotification('Purchase failed. Please try again.', 'error');
            showScreen(cryptoTradingScreen);
        }
    }

    async function handleSellCrypto() {
        if (!currentUser) {
            showNotification('Please login first', 'error');
            return;
        }

        if (!currentCryptoModal) return;
        
        const quantity = parseFloat(document.getElementById('sell-quantity')?.value) || 0;
        const symbol = currentCryptoModal.dataset.tradingSymbol;
        const crypto = cryptoPrices[symbol];
        
        if (!quantity || quantity <= 0) {
            showNotification('Please enter a valid quantity', 'error');
            return;
        }
        
        const holding = cryptoHoldings[symbol];
        if (!holding || holding.quantity < quantity) {
            showNotification('Insufficient crypto balance', 'error');
            return;
        }
        
        showLoading();
        
        try {
            const amount = quantity * crypto.price;
            const fee = amount * 0.005;
            const total = amount - fee;
            
            // Update user balance
            currentUser.balance += total;
            
            // Update crypto holdings
            holding.quantity -= quantity;
            if (holding.quantity <= 0) {
                delete cryptoHoldings[symbol];
            }
            
            // Save updated user and holdings
            await saveUser(currentUser);
            await saveCryptoHoldings(cryptoHoldings);
            
            // Record transaction
            const transaction = {
                from: symbol,
                to: 'USD',
                amount: amount,
                fee: fee,
                type: 'crypto_sell',
                symbol: symbol,
                quantity: quantity,
                price: crypto.price,
                date: new Date().toISOString(),
                userId: currentUser.id
            };
            
            await saveTransaction(transaction);
            
            // STORE IN DWN
            if (window.dwnManager) {
                await dwnManager.storeTradingData(currentUser.phone, {
                    symbol: symbol,
                    action: 'sell',
                    amount: amount,
                    quantity: quantity,
                    price: crypto.price,
                    timestamp: new Date().toISOString(),
                    transactionId: transaction.id
                });
            }
            
            // Reload data
            await loadUsers();
            
            // Update current user reference
            currentUser = users.find(u => u.id === currentUser.id);
            window.app.setCurrentUser(currentUser);
            
            // Update displays
            updateDashboard();
            updatePortfolioDisplay();
            displayCryptoHoldings();
            
            // Close modal and show success
            closeCryptoModal();
            showScreen(cryptoTradingScreen);
            showNotification(`Sold ${quantity.toFixed(8)} ${symbol} for $${total.toFixed(2)}`, 'success');
        } catch (error) {
            console.error("Sell crypto error:", error);
            showNotification('Sale failed. Please try again.', 'error');
            showScreen(cryptoTradingScreen);
        }
    }

    // FIXED CHART FUNCTIONS
    function renderChart(canvasId, symbol, timeframe) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        
        // Destroy existing chart if it exists
        if (currentChart) {
            currentChart.destroy();
        }
        
        // Generate mock price data based on timeframe
        const priceData = generatePriceData(timeframe);
        
        currentChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: priceData.labels,
                datasets: [{
                    label: `${symbol} Price`,
                    data: priceData.prices,
                    borderColor: '#00a651',
                    backgroundColor: 'rgba(0, 166, 81, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 3
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `Price: $${context.parsed.y.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        display: true,
                        grid: {
                            display: false
                        }
                    },
                    y: {
                        display: true,
                        grid: {
                            color: 'rgba(0,0,0,0.1)'
                        },
                        ticks: {
                            callback: function(value) {
                                return '$' + value;
                            }
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'nearest'
                }
            }
        });
    }

    function generatePriceData(timeframe) {
        const crypto = cryptoPrices[currentCryptoModal?.dataset.tradingSymbol];
        const basePrice = crypto?.price || 100;
        const now = new Date();
        
        let dataPoints = 50;
        let labels = [];
        let prices = [];
        
        // Generate data based on timeframe
        switch(timeframe) {
            case '1h':
                // 1 hour - 5 minute intervals
                for (let i = dataPoints; i >= 0; i--) {
                    const time = new Date(now.getTime() - i * 5 * 60 * 1000);
                    labels.push(time.getHours().toString().padStart(2, '0') + ':' + 
                               time.getMinutes().toString().padStart(2, '0'));
                    prices.push(generatePricePoint(basePrice, i, dataPoints, 0.02));
                }
                break;
                
            case '1d':
                // 1 day - hourly intervals
                for (let i = dataPoints; i >= 0; i--) {
                    const time = new Date(now.getTime() - i * 60 * 60 * 1000);
                    labels.push(time.getHours().toString().padStart(2, '0') + ':00');
                    prices.push(generatePricePoint(basePrice, i, dataPoints, 0.05));
                }
                break;
                
            case '7d':
                // 7 days - 4 hour intervals
                for (let i = dataPoints; i >= 0; i--) {
                    const time = new Date(now.getTime() - i * 4 * 60 * 60 * 1000);
                    labels.push(time.getDate() + '/' + (time.getMonth() + 1));
                    prices.push(generatePricePoint(basePrice, i, dataPoints, 0.1));
                }
                break;
                
            case '1m':
                // 1 month - daily intervals
                for (let i = dataPoints; i >= 0; i--) {
                    const time = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
                    labels.push(time.getDate() + '/' + (time.getMonth() + 1));
                    prices.push(generatePricePoint(basePrice, i, dataPoints, 0.15));
                }
                break;
                
            case '1y':
                // 1 year - weekly intervals
                for (let i = dataPoints; i >= 0; i--) {
                    const time = new Date(now.getTime() - i * 7 * 24 * 60 * 60 * 1000);
                    labels.push(time.getDate() + '/' + (time.getMonth() + 1));
                    prices.push(generatePricePoint(basePrice, i, dataPoints, 0.3));
                }
                break;
                
            default:
                // Default to 1 day
                for (let i = dataPoints; i >= 0; i--) {
                    const time = new Date(now.getTime() - i * 60 * 60 * 1000);
                    labels.push(time.getHours().toString().padStart(2, '0') + ':00');
                    prices.push(generatePricePoint(basePrice, i, dataPoints, 0.05));
                }
        }
        
        return { labels, prices };
    }

    function generatePricePoint(basePrice, index, totalPoints, volatility) {
        // Generate realistic price movement with some randomness
        const trend = Math.sin(index / totalPoints * Math.PI * 2) * 0.1;
        const random = (Math.random() - 0.5) * volatility;
        return basePrice * (1 + trend + random);
    }

    function updateChartTimeframe(timeframe) {
        currentChartTimeframe = timeframe;
        
        // Update active button
        document.querySelectorAll('.timeframe-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        event.target.classList.add('active');
        
        // Re-render chart with new timeframe
        const symbol = currentCryptoModal?.dataset.tradingSymbol;
        if (symbol) {
            renderChart('crypto-chart', symbol, timeframe);
        }
    }

    // AI Trader Functions
    async function showAiTraderScreen() {
        if (!currentUser) {
            showNotification('Please login first to access AI trading', 'error');
            showScreen(authScreen);
            return;
        }

        showScreen(aiTraderScreen);
        await loadUserAiTraders();
        displayAvailableAiTraders();
        updateAiDashboardStats();
    }

    function displayAvailableAiTraders() {
        aiTraderList.innerHTML = '';
        
        if (AI_TRADERS.length === 0) {
            aiTraderList.innerHTML = '<p class="no-crypto">No AI traders available</p>';
            return;
        }
        
        AI_TRADERS.forEach(ai => {
            const aiCard = document.createElement('div');
            aiCard.className = 'crypto-item';
            
            aiCard.innerHTML = `
                <div class="crypto-info">
                    <div class="crypto-icon ${ai.color}">${ai.avatar}</div>
                    <div class="crypto-details">
                        <div class="crypto-name">${ai.name}</div>
                        <div class="crypto-symbol">${ai.strategy}</div>
                        <div class="crypto-symbol">Risk: ${ai.riskLevel} | Win Rate: ${ai.winRate}%</div>
                    </div>
                </div>
                <div class="crypto-price">
                    <div class="crypto-current positive">+${ai.performance}%</div>
                    <div class="crypto-change">Avg. Monthly</div>
                </div>
                <div class="crypto-actions">
                    <button class="btn-trade" data-ai-id="${ai.id}" data-action="details">Details</button>
                    <button class="btn-trade" data-ai-id="${ai.id}" data-action="hire">Hire</button>
                </div>
            `;
            
            aiTraderList.appendChild(aiCard);
        });
        
        updateMyAiTradersList();
    }

    function updateMyAiTradersList() {
        myAiTradersList.innerHTML = '';
        
        if (userAiTraders.length === 0) {
            myAiTradersList.innerHTML = '<p class="no-holdings">No active AI traders</p>';
            return;
        }
        
        userAiTraders.forEach(trader => {
            const ai = AI_TRADERS.find(a => a.id === trader.aiId);
            if (!ai) return;
            
            const expiresDate = new Date(trader.expiresAt);
            const daysLeft = Math.ceil((expiresDate - new Date()) / (1000 * 60 * 60 * 24));
            const profitPercentage = ((trader.profit / trader.investment) * 100).toFixed(2);
            
            const traderCard = document.createElement('div');
            traderCard.className = 'holding-item';
            
            traderCard.innerHTML = `
                <div class="holding-info">
                    <div class="holding-icon ${ai.color}">${ai.avatar}</div>
                    <div class="holding-details">
                        <div class="holding-name">${ai.name}</div>
                        <div class="holding-symbol">${daysLeft} days left</div>
                        <div class="holding-symbol">Trades: ${trader.trades || 0}</div>
                    </div>
                </div>
                <div class="holding-quantity">
                    <div class="holding-amount">$${trader.investment.toFixed(2)}</div>
                    <div class="holding-value">Invested</div>
                </div>
                <div class="holding-change ${trader.profit >= 0 ? 'positive' : 'negative'}">
                    ${trader.profit >= 0 ? '‚Üó' : '‚Üò'} $${trader.profit.toFixed(2)} (${profitPercentage}%)
                </div>
                <div class="crypto-actions">
                    <button class="btn-trade" data-trader-id="${trader.id}" data-action="cancel">Cancel</button>
                </div>
            `;
            
            myAiTradersList.appendChild(traderCard);
        });
    }

    function updateAiDashboardStats() {
        activeAiCount.textContent = userAiTraders.length;
        
        const totalInvestment = userAiTraders.reduce((sum, trader) => sum + trader.investment, 0);
        const totalProfit = userAiTraders.reduce((sum, trader) => sum + (trader.profit || 0), 0);
        
        totalAiInvestment.textContent = `USD ${totalInvestment.toFixed(2)}`;
        totalAiProfit.textContent = `USD ${totalProfit.toFixed(2)}`;
        
        // Calculate success rate based on profitable traders
        const profitableTraders = userAiTraders.filter(trader => (trader.profit || 0) > 0).length;
        const successRate = userAiTraders.length > 0 ? 
            Math.round((profitableTraders / userAiTraders.length) * 100) : 0;
        aiSuccessRate.textContent = `${successRate}%`;
    }

    function filterAiTraders() {
        const searchTerm = aiSearch.value.toLowerCase();
        
        if (!searchTerm) {
            displayAvailableAiTraders();
            return;
        }
        
        const filteredAi = AI_TRADERS.filter(ai => 
            ai.name.toLowerCase().includes(searchTerm) || 
            ai.strategy.toLowerCase().includes(searchTerm) ||
            ai.riskLevel.toLowerCase().includes(searchTerm)
        );
        
        aiTraderList.innerHTML = '';
        
        if (filteredAi.length === 0) {
            aiTraderList.innerHTML = '<p class="no-crypto">No AI traders found</p>';
            return;
        }
        
        filteredAi.forEach(ai => {
            const aiCard = document.createElement('div');
            aiCard.className = 'crypto-item';
            
            aiCard.innerHTML = `
                <div class="crypto-info">
                    <div class="crypto-icon ${ai.color}">${ai.avatar}</div>
                    <div class="crypto-details">
                        <div class="crypto-name">${ai.name}</div>
                        <div class="crypto-symbol">${ai.strategy}</div>
                        <div class="crypto-symbol">Risk: ${ai.riskLevel} | Win Rate: ${ai.winRate}%</div>
                    </div>
                </div>
                <div class="crypto-price">
                    <div class="crypto-current positive">+${ai.performance}%</div>
                    <div class="crypto-change">Avg. Monthly</div>
                </div>
                <div class="crypto-actions">
                    <button class="btn-trade" data-ai-id="${ai.id}" data-action="details">Details</button>
                    <button class="btn-trade" data-ai-id="${ai.id}" data-action="hire">Hire</button>
                </div>
            `;
            
            aiTraderList.appendChild(aiCard);
        });
    }

    // AI Trader Modal Functions
    function openHireAiModal(aiId) {
        selectedAiTrader = AI_TRADERS.find(ai => ai.id === aiId);
        if (!selectedAiTrader) return;
        
        document.getElementById('hire-ai-title').textContent = `Hire ${selectedAiTrader.name}`;
        
        document.getElementById('ai-trader-info').innerHTML = `
            <div class="crypto-info">
                <div class="crypto-icon ${selectedAiTrader.color}">${selectedAiTrader.avatar}</div>
                <div class="crypto-details">
                    <h3>${selectedAiTrader.name}</h3>
                    <p>${selectedAiTrader.strategy}</p>
                    <p>${selectedAiTrader.description}</p>
                </div>
            </div>
            <div class="exchange-rate">
                <p><strong>Win Rate:</strong> ${selectedAiTrader.winRate}%</p>
                <p><strong>Risk Level:</strong> ${selectedAiTrader.riskLevel}</p>
                <p><strong>Avg. Monthly Return:</strong> <span class="positive">+${selectedAiTrader.performance}%</span></p>
            </div>
        `;
        
        // Reset form
        investmentAmount.value = '';
        durationSelect.value = '30';
        updateAiCostCalculation();
        
        hireAiModal.classList.remove('hidden');
    }

    function closeAiModals() {
        hireAiModal.classList.add('hidden');
        selectedAiTrader = null;
    }

    function updateAiCostCalculation() {
        const amount = parseFloat(investmentAmount.value) || 0;
        const duration = parseInt(durationSelect.value);
        const fee = DURATION_PRICES[duration] || 0;
        
        currentInvestment = amount;
        
        displayInvestment.textContent = `USD ${amount.toFixed(2)}`;
        displayFee.textContent = `USD ${fee.toFixed(2)}`;
        displayTotal.textContent = `USD ${(amount + fee).toFixed(2)}`;
    }

    async function handleHireAi() {
        const amount = parseFloat(investmentAmount.value) || 0;
        const duration = parseInt(durationSelect.value);
        
        if (amount < 50) {
            showNotification('Minimum investment is $50', 'error');
            return;
        }
        
        if (!selectedAiTrader) {
            showNotification('Please select an AI trader', 'error');
            return;
        }
        
        const fee = DURATION_PRICES[duration];
        const totalCost = amount + fee;
        
        // Check if user has sufficient balance
        if (currentUser.balance < totalCost) {
            showNotification('Insufficient balance to hire this AI trader', 'error');
            return;
        }
        
        showLoading();
        
        try {
            // Deduct the cost from user balance
            currentUser.balance -= totalCost;
            await saveUser(currentUser);
            
            // Create AI trader record
            const aiTraderRecord = {
                id: generateAiId(),
                userId: currentUser.id,
                userPhone: currentUser.phone,
                aiId: selectedAiTrader.id,
                aiName: selectedAiTrader.name,
                investment: amount,
                fee: fee,
                duration: duration,
                hiredAt: new Date().toISOString(),
                expiresAt: new Date(Date.now() + duration * 24 * 60 * 60 * 1000).toISOString(),
                status: 'active',
                profit: 0,
                trades: 0,
                lastTrade: null,
                algorithm: selectedAiTrader.algorithm
            };
            
            // Save to Firebase
            await set(ref(database, `userAiTraders/${currentUser.id}/${aiTraderRecord.id}`), aiTraderRecord);
            
            // Record transaction for user (investment)
            const investmentTransaction = {
                from: currentUser.phone,
                to: `AI_TRADER_${selectedAiTrader.id}`,
                amount: amount,
                fee: 0,
                type: 'ai_investment',
                date: new Date().toISOString(),
                userId: currentUser.id,
                status: 'completed'
            };
            
            await saveTransaction(investmentTransaction);
            
            // Record transaction for admin (fee)
            const feeTransaction = {
                from: currentUser.phone,
                to: 'ADMIN',
                amount: fee,
                fee: 0,
                type: 'ai_trader_fee',
                date: new Date().toISOString(),
                userId: currentUser.id,
                status: 'completed',
                description: `AI Trader Fee: ${selectedAiTrader.name} for ${duration} days`
            };
            
            await saveTransaction(feeTransaction);
            
            // STORE IN DWN
            if (window.dwnManager) {
                await dwnManager.storeAITraderData(currentUser.phone, {
                    aiId: selectedAiTrader.id,
                    aiName: selectedAiTrader.name,
                    investment: amount,
                    fee: fee,
                    duration: duration,
                    timestamp: new Date().toISOString(),
                    transactionId: investmentTransaction.id
                });
            }
            
            // Add to admin balance
            const adminUser = users.find(u => u.isAdmin);
            if (adminUser) {
                adminUser.balance += fee;
                await saveUser(adminUser);
            }
            
            // Add to user's AI traders
            userAiTraders.push(aiTraderRecord);
            
            // Start the AI trader immediately
            startAITrading(aiTraderRecord);
            
            // Update UI
            updateMyAiTradersList();
            updateAiDashboardStats();
            updateDashboard();
            
            closeAiModals();
            hideLoading();
            
            showNotification(`Successfully hired ${selectedAiTrader.name}! Your AI trader is now active.`, 'success');
            
        } catch (error) {
            console.error("Error hiring AI trader:", error);
            hideLoading();
            showNotification('Failed to hire AI trader. Please try again.', 'error');
        }
    }

    async function cancelAiTrader(traderId) {
        if (!confirm('Are you sure you want to cancel this AI trader? You will receive your remaining investment back.')) {
            return;
        }
        
        showLoading();
        
        try {
            const trader = userAiTraders.find(t => t.id === traderId);
            if (!trader) {
                showNotification('AI trader not found', 'error');
                return;
            }
            
            // Stop the trading interval
            if (trader.tradingInterval) {
                clearInterval(trader.tradingInterval);
                activeTradingIntervals = activeTradingIntervals.filter(i => i !== trader.tradingInterval);
            }
            
            // Calculate refund (investment + profit)
            const refundAmount = trader.investment + (trader.profit || 0);
            
            // Update user balance
            currentUser.balance += refundAmount;
            await saveUser(currentUser);
            
            // Record refund transaction
            const refundTransaction = {
                from: `AI_TRADER_${trader.aiId}`,
                to: currentUser.phone,
                amount: refundAmount,
                fee: 0,
                type: 'ai_refund',
                date: new Date().toISOString(),
                userId: currentUser.id,
                status: 'completed',
                description: `Refund from ${trader.aiName} cancellation`
            };
            
            await saveTransaction(refundTransaction);
            
            // Update the trader status to cancelled
            await update(ref(database, `userAiTraders/${currentUser.id}/${traderId}`), {
                status: 'cancelled',
                cancelledAt: new Date().toISOString(),
                refundAmount: refundAmount
            });
            
            // Remove from local array
            userAiTraders = userAiTraders.filter(t => t.id !== traderId);
            
            // Update UI
            updateMyAiTradersList();
            updateAiDashboardStats();
            updateDashboard();
            
            hideLoading();
            
            showNotification(`AI trader cancelled successfully. $${refundAmount.toFixed(2)} has been refunded to your account.`, 'success');
            
        } catch (error) {
            console.error("Error cancelling AI trader:", error);
            hideLoading();
            showNotification('Failed to cancel AI trader. Please try again.', 'error');
        }
    }

    function generateAiId() {
        return 'ai_' + Math.random().toString(36).substr(2, 9);
    }

    function showAiTraderDetails(aiId) {
        const ai = AI_TRADERS.find(a => a.id === aiId);
        if (!ai) return;
        
        const featuresHtml = ai.features.map(feature => 
            `<div class="feature"><i class="fas fa-check"></i> ${feature}</div>`
        ).join('');
        
        alert(
            `${ai.name} - ${ai.strategy}\n\n` +
            `Description: ${ai.description}\n\n` +
            `Performance: +${ai.performance}% avg monthly\n` +
            `Win Rate: ${ai.winRate}%\n` +
            `Risk Level: ${ai.riskLevel}\n` +
            `Average Trade Size: $${ai.avgTradeSize}\n\n` +
            `Features:\n${ai.features.join('\n')}\n\n` +
            `Monthly Fee: $${ai.fee}`
        );
    }

    // Identity Management Functions
    function showIdentityManagementScreen() {
        if (!currentUser) {
            showNotification('Please login first', 'error');
            return;
        }
        
        showScreen(identityManagementScreen);
        updateDIDStatus();
    }

    async function updateDIDStatus() {
        const hasDID = await didManager.hasDID(currentUser.phone);
        
        if (hasDID) {
            const did = await didManager.getStoredDID(currentUser.phone);
            didStatus.innerHTML = `
                <div class="status-item">
                    <span class="status-label">DID:</span>
                    <span class="status-value">${did.did}</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Status:</span>
                    <span class="status-badge status-active">Active</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Created:</span>
                    <span class="status-value">${new Date(did.document.created).toLocaleDateString()}</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Last Accessed:</span>
                    <span class="status-value">${new Date(did.document.userMetadata.lastAccessed).toLocaleDateString()}</span>
                </div>
            `;
        } else {
            didStatus.innerHTML = `
                <div class="status-item">
                    <span class="status-label">Status:</span>
                    <span class="status-badge status-pending">No DID Found</span>
                </div>
                <div class="status-item">
                    <p>You don't have a decentralized identity yet.</p>
                    <button class="btn btn-primary" id="create-did-btn">Create DID</button>
                </div>
            `;
            
            document.getElementById('create-did-btn').addEventListener('click', async () => {
                try {
                    await didManager.createDID(currentUser);
                    await dwnManager.initializeDWN(currentUser.phone, currentUser);
                    updateDIDStatus();
                    showNotification('Decentralized identity created successfully!', 'success');
                } catch (error) {
                    showNotification('Failed to create identity: ' + error.message, 'error');
                }
            });
        }
    }

    function showExportIdentityModal() {
        exportIdentityModal.classList.remove('hidden');
    }

    // FIXED EXPORT IDENTITY FUNCTION
    async function handleExportIdentity() {
        const password = exportPassword.value;
        const confirmPassword = confirmExportPassword.value;
        
        if (!password || password.length < 8) {
            showNotification('Password must be at least 8 characters', 'error');
            return;
        }
        
        if (password !== confirmPassword) {
            showNotification('Passwords do not match', 'error');
            return;
        }
        
        showLoading();
        
        try {
            const result = await didManager.exportIdentity(currentUser.phone, password);
            
            if (result.success) {
                // Create and trigger download with proper JSON formatting
                const exportData = {
                    type: 'M-USD Identity Backup',
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    userPhone: currentUser.phone,
                    data: result.data
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { 
                    type: 'application/json;charset=utf-8' 
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `musd-identity-${currentUser.phone}-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                exportIdentityModal.classList.add('hidden');
                // Clear passwords
                exportPassword.value = '';
                confirmExportPassword.value = '';
                hideLoading();
                showNotification('Identity exported and downloaded successfully!', 'success');
            } else {
                hideLoading();
                showNotification('Export failed: ' + result.error, 'error');
            }
        } catch (error) {
            console.error('Export error:', error);
            hideLoading();
            showNotification('Export failed: ' + error.message, 'error');
        }
    }

    function showImportIdentityModal() {
        importIdentityModal.classList.remove('hidden');
    }

    async function handleImportIdentity() {
        const file = identityFile.files[0];
        const password = importPassword.value;
        const phone = importPhone.value;
        
        if (!file) {
            showNotification('Please select a backup file', 'error');
            return;
        }
        
        if (!password) {
            showNotification('Please enter the backup password', 'error');
            return;
        }
        
        if (!phone) {
            showNotification('Please enter your phone number', 'error');
            return;
        }
        
        showLoading();
        
        try {
            const fileText = await file.text();
            const backupData = JSON.parse(fileText);
            
            const result = await didManager.importIdentity(backupData, password, phone);
            
            if (result.success) {
                importIdentityModal.classList.add('hidden');
                // Clear form
                identityFile.value = '';
                importPassword.value = '';
                importPhone.value = '';
                hideLoading();
                showNotification('Identity imported successfully!', 'success');
                
                // Update status if current user
                if (currentUser && currentUser.phone === phone) {
                    updateDIDStatus();
                }
            } else {
                hideLoading();
                showNotification('Import failed: ' + result.error, 'error');
            }
        } catch (error) {
            console.error('Import error:', error);
            hideLoading();
            showNotification('Import failed: Invalid file or password', 'error');
        }
    }

    async function backupDWNData() {
        const password = prompt('Enter encryption password for DWN backup:');
        if (!password) return;
        
        if (password.length < 8) {
            showNotification('Password must be at least 8 characters', 'error');
            return;
        }
        
        showLoading();
        
        try {
            const result = await dwnManager.exportDWNData(currentUser.phone, password);
            
            if (result.success) {
                // Create and trigger download with proper JSON formatting
                const backupData = {
                    type: 'M-USD DWN Backup',
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    userPhone: currentUser.phone,
                    data: result.data
                };
                
                const blob = new Blob([JSON.stringify(backupData, null, 2)], { 
                    type: 'application/json;charset=utf-8' 
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `musd-dwn-backup-${currentUser.phone}-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                hideLoading();
                showNotification('DWN data backed up and downloaded successfully!', 'success');
            } else {
                hideLoading();
                showNotification('Backup failed: ' + result.error, 'error');
            }
        } catch (error) {
            console.error('DWN backup error:', error);
            hideLoading();
            showNotification('Backup failed: ' + error.message, 'error');
        }
    }

    async function restoreDWNData() {
        // Create file input for backup upload
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const password = prompt('Enter the backup password:');
            if (!password) return;
            
            showLoading();
            
            try {
                const fileText = await file.text();
                const backupData = JSON.parse(fileText);
                
                const result = await dwnManager.importDWNData(currentUser.phone, backupData, password);
                
                if (result.success) {
                    hideLoading();
                    showNotification('DWN data restored successfully!', 'success');
                } else {
                    hideLoading();
                    showNotification('Restore failed: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('DWN restore error:', error);
                hideLoading();
                showNotification('Restore failed: Invalid file or password', 'error');
            }
        };
        
        input.click();
    }

    async function showDIDDocument() {
        const did = await didManager.getStoredDID(currentUser.phone);
        
        if (!did) {
            showNotification('No DID document found', 'error');
            return;
        }
        
        didDocumentContent.textContent = JSON.stringify(did.document, null, 2);
        didDocumentModal.classList.remove('hidden');
    }

    function copyDIDDocument() {
        navigator.clipboard.writeText(didDocumentContent.textContent).then(() => {
            showNotification('DID document copied to clipboard', 'success');
        }).catch(err => {
            console.error('Failed to copy: ', err);
            showNotification('Failed to copy DID document', 'error');
        });
    }

    function downloadDIDDocument() {
        const blob = new Blob([didDocumentContent.textContent], { 
            type: 'application/json;charset=utf-8' 
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `did-document-${currentUser.phone}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showNotification('DID document downloaded', 'success');
    }

    // Enhanced Sync Functionality
    async function syncDevices() {
        showLoading();
        
        try {
            // Show progress updates
            const syncStatus = document.createElement('div');
            syncStatus.innerHTML = `
                <div class="payment-success">
                    <i class="fas fa-sync-alt fa-spin"></i>
                    <h2>üîÑ Syncing Your Data</h2>
                    <p>Synchronizing across all your devices...</p>
                    <div class="loading">
                        <div class="spinner"></div>
                        <p id="sync-progress">Initializing sync...</p>
                    </div>
                </div>
            `;
            
            // Replace the loading screen with sync status
            loadingScreen.innerHTML = '';
            loadingScreen.appendChild(syncStatus);
            
            // Step 1: Sync user profile
            document.getElementById('sync-progress').textContent = 'Syncing profile data...';
            const profileResult = await dwnManager.syncProfileData(currentUser.phone);
            
            // Step 2: Sync transactions
            document.getElementById('sync-progress').textContent = 'Syncing transaction history...';
            const transactionResult = await dwnManager.syncTransactions(currentUser.phone);
            
            // Step 3: Sync crypto portfolio
            document.getElementById('sync-progress').textContent = 'Syncing crypto portfolio...';
            const cryptoResult = await dwnManager.syncCryptoData(currentUser.phone);
            
            // Step 4: Sync AI trader data
            document.getElementById('sync-progress').textContent = 'Syncing AI trader data...';
            const aiResult = await dwnManager.syncAITraderData(currentUser.phone);
            
            // Complete sync
            document.getElementById('sync-progress').textContent = 'Sync completed successfully!';
            
            setTimeout(() => {
                showScreen(identityManagementScreen);
                showNotification('All data synchronized across devices!', 'success');
            }, 1000);
            
        } catch (error) {
            console.error('Sync error:', error);
            showNotification('Sync completed with some issues. Some data may not be synchronized.', 'warning');
            showScreen(identityManagementScreen);
        }
    }

    // Enhanced DID Authentication
    async function handleDIDLogin() {
        const phone = didPhoneInput.value;
        const signature = didSignatureInput.value;
        
        if (!phone || !signature) {
            showNotification('Please enter phone number and signature', 'error');
            return;
        }
        
        showLoading();
        
        try {
            // Update loading screen for DID authentication
            const didAuthStatus = document.createElement('div');
            didAuthStatus.innerHTML = `
                <div class="payment-success">
                    <i class="fas fa-fingerprint"></i>
                    <h2>üîê DID Authentication</h2>
                    <p>Verifying your decentralized identity...</p>
                    <div class="loading">
                        <div class="spinner"></div>
                        <p id="did-auth-progress">Initializing authentication...</p>
                    </div>
                </div>
            `;
            
            loadingScreen.innerHTML = '';
            loadingScreen.appendChild(didAuthStatus);
            
            // Step 1: Verify DID exists
            document.getElementById('did-auth-progress').textContent = 'Checking identity...';
            const hasDID = await didManager.hasDID(phone);
            
            if (!hasDID) {
                throw new Error('No decentralized identity found for this phone number');
            }
            
            // Step 2: Authenticate with signature
            document.getElementById('did-auth-progress').textContent = 'Verifying signature...';
            const result = await didManager.authenticateWithDID(phone, signature);
            
            if (!result.success) {
                throw new Error(result.error || 'Authentication failed');
            }
            
            // Step 3: Load user data
            document.getElementById('did-auth-progress').textContent = 'Loading user data...';
            await loadUsers();
            const user = users.find(u => u.phone === phone);
            
            if (!user) {
                throw new Error('User account not found');
            }
            
            if (user.isBlocked) {
                showScreen(blockedUserScreen);
                return;
            }
            
            if (user.isSuspended) {
                showNotification('Your account has been suspended. Contact support.', 'error');
                showScreen(authScreen);
                return;
            }
            
            // Step 4: Load all user data
            document.getElementById('did-auth-progress').textContent = 'Loading crypto data...';
            currentUser = user;
            window.app.setCurrentUser(user);
            
            await loadCryptoPrices();
            cryptoHoldings = await loadCryptoHoldings();
            await loadUserAiTraders();
            
            // Step 5: Start AI trading simulation if user has active AI traders
            if (userAiTraders.length > 0) {
                document.getElementById('did-auth-progress').textContent = 'Starting AI traders...';
                startAllAITraders();
            }
            
            // Complete authentication
            document.getElementById('did-auth-progress').textContent = 'Authentication successful!';
            
            setTimeout(() => {
                updateDashboard();
                showScreen(dashboardScreen);
                // CLOSE THE DID MODAL
                didLoginModal.classList.add('hidden');
                showNotification('DID authentication successful! Welcome back.', 'success');
            }, 1000);
            
        } catch (error) {
            console.error("DID login error:", error);
            showNotification('DID authentication failed: ' + error.message, 'error');
            showScreen(authScreen);
        }
    }

    // Enhanced AI Trading System with Real Crypto Prices
    async function startAllAITraders() {
        if (!currentUser || userAiTraders.length === 0) return;
        
        console.log(`Starting ${userAiTraders.length} AI traders for user ${currentUser.phone}`);
        
        // Load current crypto prices
        await loadCryptoPrices();
        
        // Clear any existing intervals
        activeTradingIntervals.forEach(interval => clearInterval(interval));
        activeTradingIntervals = [];
        
        userAiTraders.forEach(trader => {
            if (trader.status === 'active' && new Date(trader.expiresAt) > new Date()) {
                startAITrading(trader);
            }
        });
    }

    async function startAITrading(trader) {
        const aiConfig = AI_TRADERS.find(a => a.id === trader.aiId);
        if (!aiConfig) return;
        
        console.log(`Starting ${aiConfig.name} for ${currentUser.phone}`);
        
        // Calculate trading parameters based on AI strategy
        const tradingConfig = getTradingConfig(aiConfig.algorithm, trader.investment);
        
        // Start the trading loop
        const tradingInterval = setInterval(async () => {
            // Check if trader is still active
            if (trader.status !== 'active' || new Date(trader.expiresAt) <= new Date()) {
                clearInterval(tradingInterval);
                activeTradingIntervals = activeTradingIntervals.filter(i => i !== tradingInterval);
                return;
            }
            
            try {
                // Refresh crypto prices
                await loadCryptoPrices();
                
                // Execute trading strategy
                await executeTradingStrategy(trader, aiConfig, tradingConfig);
                
            } catch (error) {
                console.error(`Trading error for ${aiConfig.name}:`, error);
            }
        }, tradingConfig.interval);
        
        // Store the interval ID for cleanup
        activeTradingIntervals.push(tradingInterval);
        trader.tradingInterval = tradingInterval;
    }

    function getTradingConfig(algorithm, investment) {
        const baseConfig = {
            interval: 30000, // 30 seconds base interval
            maxPositionSize: investment * 0.1, // Max 10% per trade
            riskPerTrade: investment * 0.02, // 2% risk per trade
            maxOpenTrades: 3
        };
        
        switch(algorithm) {
            case 'arbitrage':
                return {
                    ...baseConfig,
                    interval: 15000, // 15 seconds for arbitrage
                    maxPositionSize: investment * 0.05,
                    strategy: 'arbitrage'
                };
                
            case 'neural_network':
                return {
                    ...baseConfig,
                    interval: 45000, // 45 seconds
                    maxPositionSize: investment * 0.08,
                    strategy: 'prediction'
                };
                
            case 'conservative':
                return {
                    ...baseConfig,
                    interval: 60000, // 1 minute
                    maxPositionSize: investment * 0.03,
                    riskPerTrade: investment * 0.01,
                    strategy: 'conservative'
                };
                
            case 'momentum':
                return {
                    ...baseConfig,
                    interval: 20000, // 20 seconds
                    maxPositionSize: investment * 0.12,
                    riskPerTrade: investment * 0.03,
                    strategy: 'momentum'
                };
                
            case 'cross_arbitrage':
                return {
                    ...baseConfig,
                    interval: 10000, // 10 seconds
                    maxPositionSize: investment * 0.15,
                    strategy: 'cross_arbitrage'
                };
                
            case 'volatility':
                return {
                    ...baseConfig,
                    interval: 25000, // 25 seconds
                    maxPositionSize: investment * 0.2,
                    riskPerTrade: investment * 0.05,
                    strategy: 'volatility'
                };
                
            case 'market_making':
                return {
                    ...baseConfig,
                    interval: 30000,
                    maxPositionSize: investment * 0.25,
                    strategy: 'market_making'
                };
                
            default:
                return baseConfig;
        }
    }

    async function executeTradingStrategy(trader, aiConfig, config) {
        const topCryptos = Object.values(cryptoPrices).slice(0, 10); // Top 10 cryptos
        
        switch(config.strategy) {
            case 'arbitrage':
                await executeArbitrageStrategy(trader, topCryptos, config);
                break;
                
            case 'prediction':
                await executePredictionStrategy(trader, topCryptos, config);
                break;
                
            case 'conservative':
                await executeConservativeStrategy(trader, topCryptos, config);
                break;
                
            case 'momentum':
                await executeMomentumStrategy(trader, topCryptos, config);
                break;
                
            case 'cross_arbitrage':
                await executeCrossArbitrageStrategy(trader, topCryptos, config);
                break;
                
            case 'volatility':
                await executeVolatilityStrategy(trader, topCryptos, config);
                break;
                
            case 'market_making':
                await executeMarketMakingStrategy(trader, topCryptos, config);
                break;
                
            default:
                await executeDefaultStrategy(trader, topCryptos, config);
        }
    }

    // Arbitrage Strategy - Looks for price discrepancies
    async function executeArbitrageStrategy(trader, cryptos, config) {
        // Simulate finding arbitrage opportunities
        const opportunity = findArbitrageOpportunity(cryptos);
        
        if (opportunity && Math.random() < 0.3) { // 30% chance to execute
            const tradeAmount = Math.min(config.maxPositionSize, trader.investment * 0.05);
            const profit = tradeAmount * 0.002; // 0.2% profit from arbitrage
            
            await executeTrade(trader, opportunity.symbol, 'buy', tradeAmount, profit);
        }
    }

    // Prediction Strategy - Uses simulated AI prediction
    async function executePredictionStrategy(trader, cryptos, config) {
        const crypto = cryptos[Math.floor(Math.random() * cryptos.length)];
        const prediction = Math.random() < 0.65; // 65% accuracy
        
        if (prediction && Math.random() < 0.4) { // 40% chance to trade
            const tradeAmount = Math.min(config.maxPositionSize, trader.investment * 0.08);
            const profit = prediction ? tradeAmount * 0.015 : -tradeAmount * 0.01;
            
            await executeTrade(trader, crypto.symbol, 'buy', tradeAmount, profit);
        }
    }

    // Conservative Strategy - Low risk, steady gains
    async function executeConservativeStrategy(trader, cryptos, config) {
        const stableCryptos = cryptos.filter(c => 
            Math.abs(c.change24h) < 5 && c.price > 10
        );
        
        if (stableCryptos.length > 0 && Math.random() < 0.2) { // 20% chance
            const crypto = stableCryptos[Math.floor(Math.random() * stableCryptos.length)];
            const tradeAmount = Math.min(config.maxPositionSize, trader.investment * 0.03);
            const profit = tradeAmount * 0.008; // 0.8% steady profit
            
            await executeTrade(trader, crypto.symbol, 'buy', tradeAmount, profit);
        }
    }

    // Momentum Strategy - Follows trends
    async function executeMomentumStrategy(trader, cryptos, config) {
        const trendingCryptos = cryptos.filter(c => Math.abs(c.change24h) > 8);
        
        if (trendingCryptos.length > 0 && Math.random() < 0.5) { // 50% chance
            const crypto = trendingCryptos[Math.floor(Math.random() * trendingCryptos.length)];
            const direction = crypto.change24h > 0 ? 'buy' : 'sell';
            const tradeAmount = Math.min(config.maxPositionSize, trader.investment * 0.12);
            const profit = tradeAmount * (direction === 'buy' ? 0.025 : -0.02);
            
            await executeTrade(trader, crypto.symbol, direction, tradeAmount, profit);
        }
    }

    // Cross Arbitrage Strategy - More aggressive arbitrage
    async function executeCrossArbitrageStrategy(trader, cryptos, config) {
        if (Math.random() < 0.4) { // 40% chance
            const crypto = cryptos[Math.floor(Math.random() * cryptos.length)];
            const tradeAmount = Math.min(config.maxPositionSize, trader.investment * 0.15);
            const profit = tradeAmount * 0.003; // 0.3% profit
            
            await executeTrade(trader, crypto.symbol, 'buy', tradeAmount, profit);
        }
    }

    // Volatility Strategy - Thrives in high volatility
    async function executeVolatilityStrategy(trader, cryptos, config) {
        const volatileCryptos = cryptos.filter(c => Math.abs(c.change24h) > 15);
        
        if (volatileCryptos.length > 0 && Math.random() < 0.6) { // 60% chance
            const crypto = volatileCryptos[Math.floor(Math.random() * volatileCryptos.length)];
            const tradeAmount = Math.min(config.maxPositionSize, trader.investment * 0.2);
            const profit = Math.random() < 0.58 ? tradeAmount * 0.04 : -tradeAmount * 0.03;
            
            await executeTrade(trader, crypto.symbol, 'buy', tradeAmount, profit);
        }
    }

    // Market Making Strategy - Provides liquidity
    async function executeMarketMakingStrategy(trader, cryptos, config) {
        if (Math.random() < 0.3) { // 30% chance
            const crypto = cryptos[Math.floor(Math.random() * cryptos.length)];
            const tradeAmount = Math.min(config.maxPositionSize, trader.investment * 0.25);
            const profit = tradeAmount * 0.009; // 0.9% steady profit
            
            await executeTrade(trader, crypto.symbol, 'buy', tradeAmount, profit);
        }
    }

    // Default Strategy - Fallback
    async function executeDefaultStrategy(trader, cryptos, config) {
        if (Math.random() < 0.25) { // 25% chance
            const crypto = cryptos[Math.floor(Math.random() * cryptos.length)];
            const tradeAmount = Math.min(config.maxPositionSize, trader.investment * 0.1);
            const profit = Math.random() < 0.55 ? tradeAmount * 0.012 : -tradeAmount * 0.008;
            
            await executeTrade(trader, crypto.symbol, 'buy', tradeAmount, profit);
        }
    }

    function findArbitrageOpportunity(cryptos) {
        // Simulate finding arbitrage opportunities
        if (Math.random() < 0.2) { // 20% chance of finding opportunity
            const crypto = cryptos[Math.floor(Math.random() * cryptos.length)];
            return {
                symbol: crypto.symbol,
                opportunity: 'price_discrepancy',
                potentialProfit: 0.002
            };
        }
        return null;
    }

    async function executeTrade(trader, symbol, action, amount, profit) {
        try {
            // Update trader profit
            trader.profit = (trader.profit || 0) + profit;
            trader.trades = (trader.trades || 0) + 1;
            trader.lastTrade = new Date().toISOString();
            
            // Update in Firebase
            await update(ref(database, `userAiTraders/${currentUser.id}/${trader.id}`), {
                profit: trader.profit,
                trades: trader.trades,
                lastTrade: trader.lastTrade
            });
            
            // Record trade in DWN
            if (window.dwnManager) {
                await dwnManager.storeAITrade(currentUser.phone, {
                    traderId: trader.id,
                    symbol: symbol,
                    action: action,
                    amount: amount,
                    profit: profit,
                    timestamp: new Date().toISOString()
                });
            }
            
            console.log(`AI Trade: ${trader.aiName} ${action} ${symbol} - Profit: $${profit.toFixed(2)}`);
            
            // Update UI if on AI trader screen
            if (document.getElementById('ai-trader-screen') && 
                !document.getElementById('ai-trader-screen').classList.contains('hidden')) {
                updateMyAiTradersList();
                updateAiDashboardStats();
            }
            
        } catch (error) {
            console.error('Error executing AI trade:', error);
        }
    }

    // VC Management Functions - ADDED
    async function showVcManagementScreen() {
        if (!currentUser) {
            showNotification('Please login first', 'error');
            return;
        }
        
        showScreen(vcManagementScreen);
        
        // Initialize VC buttons
        initializeVcButtons();
        
        // Load any existing VCs
        await loadUserVCs();
    }

    // Initialize VC Buttons
    function initializeVcButtons() {
        // Remove existing event listeners first to avoid duplicates
        const kycBtn = document.getElementById('issue-kyc-certificate');
        const tradingBtn = document.getElementById('issue-trading-certificate');
        
        // Clone and replace to remove existing listeners
        const newKycBtn = kycBtn.cloneNode(true);
        const newTradingBtn = tradingBtn.cloneNode(true);
        
        kycBtn.parentNode.replaceChild(newKycBtn, kycBtn);
        tradingBtn.parentNode.replaceChild(newTradingBtn, tradingBtn);
        
        // Issue KYC Certificate
        document.getElementById('issue-kyc-certificate').addEventListener('click', async () => {
            if (!currentUser) {
                showNotification('Please login first', 'error');
                return;
            }
            
            showLoading();
            
            try {
                // Get user DID
                const did = await didManager.getStoredDID(currentUser.phone);
                if (!did) {
                    throw new Error('No DID found. Please create a digital identity first.');
                }
                
                // Initialize VC Manager
                await vcManager.initialize();
                
                // Prepare user data
                const userData = {
                    phone: currentUser.phone,
                    dateCreated: currentUser.dateCreated,
                    kycStatus: 'verified',
                    verificationDate: new Date().toISOString(),
                    level: 'full',
                    balance: currentUser.balance
                };
                
                // Issue KYC VC
                const result = await vcManager.issueKYCCredential(did.did, userData);
                
                if (result.success) {
                    // Store the VC
                    await vcManager.storeVC(did.did, result.vc);
                    
                    // Save to Firebase
                    await saveVCToFirebase(result.vc);
                    
                    hideLoading();
                    showNotification('KYC Certificate issued successfully!', 'success');
                    await loadUserVCs();
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                console.error('Error issuing KYC certificate:', error);
                hideLoading();
                showNotification('Failed to issue KYC certificate: ' + error.message, 'error');
            }
        });
        
        // Issue Trading Certificate
        document.getElementById('issue-trading-certificate').addEventListener('click', async () => {
            if (!currentUser) {
                showNotification('Please login first', 'error');
                return;
            }
            
            showLoading();
            
            try {
                // Get user DID
                const did = await didManager.getStoredDID(currentUser.phone);
                if (!did) {
                    throw new Error('No DID found. Please create a digital identity first.');
                }
                
                // Initialize VC Manager
                await vcManager.initialize();
                
                // Calculate trading level
                const portfolioValue = calculatePortfolioValue();
                let tradingLevel = 'beginner';
                if (portfolioValue.total > 10000) tradingLevel = 'expert';
                else if (portfolioValue.total > 1000) tradingLevel = 'advanced';
                else if (portfolioValue.total > 100) tradingLevel = 'intermediate';
                
                // Prepare trading data
                const tradingData = {
                    level: tradingLevel,
                    limits: {
                        daily: 10000,
                        monthly: 100000
                    },
                    pairs: ['BTC/USD', 'ETH/USD', 'BNB/USD'],
                    riskLevel: 'medium',
                    portfolioValue: portfolioValue.total
                };
                
                // Issue Trading VC
                const result = await vcManager.issueTradingCredential(did.did, tradingData);
                
                if (result.success) {
                    // Store the VC
                    await vcManager.storeVC(did.did, result.vc);
                    
                    // Save to Firebase
                    await saveVCToFirebase(result.vc);
                    
                    hideLoading();
                    showNotification('Trading Certificate issued successfully!', 'success');
                    await loadUserVCs();
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                console.error('Error issuing trading certificate:', error);
                hideLoading();
                showNotification('Failed to issue trading certificate: ' + error.message, 'error');
            }
        });
    }

    // Save VC to Firebase
    async function saveVCToFirebase(vc) {
        try {
            const vcRef = ref(database, `verifiableCredentials/${currentUser.id}`);
            await push(vcRef, {
                ...vc,
                storedAt: new Date().toISOString(),
                userId: currentUser.id,
                userPhone: currentUser.phone
            });
            console.log('VC saved to Firebase');
        } catch (error) {
            console.error('Error saving VC to Firebase:', error);
        }
    }

    // Load User VCs
    async function loadUserVCs() {
        const vcList = document.getElementById('vc-list');
        if (!vcList) return;
        
        vcList.innerHTML = '<div class="loading"><div class="spinner"></div><p>Loading credentials...</p></div>';
        
        if (!currentUser) {
            vcList.innerHTML = '<p class="no-transactions">Please login to view credentials</p>';
            return;
        }
        
        try {
            // Try to load from Firebase first
            const vcRef = ref(database, `verifiableCredentials/${currentUser.id}`);
            const snapshot = await get(vcRef);
            
            if (snapshot.exists()) {
                const vcs = Object.values(snapshot.val());
                displayVCs(vcs);
            } else {
                vcList.innerHTML = '<p class="no-transactions">No verifiable credentials yet. Issue a KYC or Trading certificate to get started.</p>';
            }
        } catch (error) {
            console.error('Error loading VCs:', error);
            vcList.innerHTML = '<p class="no-transactions">Error loading credentials</p>';
        }
    }

    // Display VCs
    function displayVCs(vcs) {
        const vcList = document.getElementById('vc-list');
        if (!vcList) return;
        
        vcList.innerHTML = '';
        
        if (vcs.length === 0) {
            vcList.innerHTML = '<p class="no-transactions">No verifiable credentials found</p>';
            return;
        }
        
        vcs.forEach((vc, index) => {
            const vcEl = document.createElement('div');
            vcEl.className = 'transaction-item';
            
            // Determine VC type
            let vcType = 'Unknown Credential';
            let vcDetails = '';
            
            if (vc.type && Array.isArray(vc.type)) {
                if (vc.type.includes('KYCIdentityCredential')) {
                    vcType = 'KYC Certificate';
                    vcDetails = `Level: ${vc.credentialSubject?.kycLevel || 'Unknown'}`;
                } else if (vc.type.includes('CryptoTradingCredential')) {
                    vcType = 'Trading Certificate';
                    vcDetails = `Level: ${vc.credentialSubject?.tradingLevel || 'Unknown'}`;
                }
            }
            
            const issueDate = new Date(vc.issuanceDate).toLocaleDateString();
            const subjectPhone = vc.credentialSubject?.phone || currentUser.phone;
            
            vcEl.innerHTML = `
                <div class="transaction-details">
                    <div class="transaction-type">${vcType}</div>
                    <div class="transaction-date">Issued: ${issueDate}</div>
                    <div class="transaction-parties">User: ${subjectPhone}</div>
                    <div class="transaction-method">${vcDetails}</div>
                    <div class="transaction-method">Issuer: ${vc.issuer || 'M-USD'}</div>
                </div>
                <div class="transaction-amount">
                    <button class="btn btn-outline" onclick="viewVCDetails(${index})">View</button>
                    <button class="btn btn-outline" onclick="exportVC(${index})">Export</button>
                </div>
            `;
            
            // Store VC data in data attribute
            vcEl.dataset.vcData = JSON.stringify(vc);
            
            vcList.appendChild(vcEl);
        });
    }

    // View VC Details
    window.viewVCDetails = function(index) {
        const vcItems = document.querySelectorAll('#vc-list .transaction-item');
        if (index >= 0 && index < vcItems.length) {
            const vcData = JSON.parse(vcItems[index].dataset.vcData);
            
            // Create modal
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex';
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h2>Verifiable Credential Details</h2>
                        <span class="close-modal" onclick="this.parentElement.parentElement.parentElement.remove()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <h3 style="margin-top: 0;">Credential Information</h3>
                            <p><strong>Type:</strong> ${vcData.type ? (Array.isArray(vcData.type) ? vcData.type.join(', ') : vcData.type) : 'Unknown'}</p>
                            <p><strong>Issuer:</strong> ${vcData.issuer || 'Unknown'}</p>
                            <p><strong>Issued:</strong> ${new Date(vcData.issuanceDate).toLocaleString()}</p>
                            <p><strong>Credential ID:</strong> ${vcData.id || 'N/A'}</p>
                        </div>
                        
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <h3>Subject Information</h3>
                            <pre style="white-space: pre-wrap; font-size: 12px; max-height: 200px; overflow-y: auto;">
${JSON.stringify(vcData.credentialSubject, null, 2)}
                            </pre>
                        </div>
                        
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                            <h3>Proof</h3>
                            <p><strong>Type:</strong> ${vcData.proof?.type || 'None'}</p>
                            <p><strong>Created:</strong> ${vcData.proof?.created ? new Date(vcData.proof.created).toLocaleString() : 'N/A'}</p>
                            <p><strong>Status:</strong> <span style="color: green;">‚úì Verified</span></p>
                        </div>
                        
                        <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                            <button class="btn btn-outline" onclick="window.exportVC(${index})">
                                <i class="fas fa-download"></i> Export
                            </button>
                            <button class="btn btn-primary" onclick="this.parentElement.parentElement.parentElement.parentElement.remove()">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
    };

    // Download VC
    window.exportVC = function(index) {
        const vcItems = document.querySelectorAll('#vc-list .transaction-item');
        if (index >= 0 && index < vcItems.length) {
            const vcData = JSON.parse(vcItems[index].dataset.vcData);
            
            const exportData = {
                type: 'M-USD Verifiable Credential',
                version: '1.0',
                timestamp: new Date().toISOString(),
                credential: vcData
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { 
                type: 'application/json;charset=utf-8' 
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // Create filename based on credential type
            let filename = 'credential';
            if (vcData.type && Array.isArray(vcData.type)) {
                if (vcData.type.includes('KYCIdentityCredential')) filename = 'kyc-certificate';
                else if (vcData.type.includes('CryptoTradingCredential')) filename = 'trading-certificate';
            }
            
            a.download = `musd-${filename}-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('Credential exported successfully!', 'success');
        }
    };

    // Deposit/Withdraw Functions
    function switchDepositWithdrawTab(tab) {
        if (tab === 'deposit') {
            depositTab.classList.add('active');
            withdrawTab.classList.remove('active');
            depositSection.classList.remove('hidden');
            withdrawSection.classList.add('hidden');
            
            // Reset payment method to PayPal
            switchPaymentMethod('paypal');
        } else if (tab === 'withdraw') {
            withdrawTab.classList.add('active');
            depositTab.classList.remove('active');
            withdrawSection.classList.remove('hidden');
            depositSection.classList.add('hidden');
            
            // Reset payment method to PayPal
            switchPaymentMethod('paypal');
        }
    }

    function switchPaymentMethod(method) {
        if (method === 'paypal') {
            paypalTab.classList.add('active');
            mpesaTab.classList.remove('active');
            
            // Show/hide appropriate sections based on deposit/withdraw tab
            if (depositTab.classList.contains('active')) {
                paypalMethod.classList.remove('hidden');
                mpesaMethod.classList.add('hidden');
            } else {
                paypalWithdrawMethod.classList.remove('hidden');
                mpesaWithdrawMethod.classList.add('hidden');
            }
            
            // Hide exchange rate for PayPal
            depositExchangeRate.classList.add('hidden');
            withdrawExchangeRate.classList.add('hidden');
        } else if (method === 'mpesa') {
            mpesaTab.classList.add('active');
            paypalTab.classList.remove('active');
            
            // Show/hide appropriate sections based on deposit/withdraw tab
            if (depositTab.classList.contains('active')) {
                mpesaMethod.classList.remove('hidden');
                paypalMethod.classList.add('hidden');
                
                // Show exchange rate for M-Pesa deposit
                depositExchangeRate.classList.remove('hidden');
                withdrawExchangeRate.classList.add('hidden');
                
                // Pre-fill M-Pesa phone with user's phone if available
                if (currentUser && mpesaPhoneInput) {
                    mpesaPhoneInput.value = currentUser.phone;
                }
                
                // Reset M-Pesa status
                if (mpesaStatus) {
                    mpesaStatus.classList.add('hidden');
                }
            } else {
                mpesaWithdrawMethod.classList.remove('hidden');
                paypalWithdrawMethod.classList.add('hidden');
                
                // Show exchange rate for M-Pesa withdrawal
                withdrawExchangeRate.classList.remove('hidden');
                depositExchangeRate.classList.add('hidden');
                
                // Pre-fill M-Pesa phone with user's phone if available
                if (currentUser && mpesaWithdrawPhoneInput) {
                    mpesaWithdrawPhoneInput.value = currentUser.phone;
                }
                
                // Reset M-Pesa status
                if (mpesaWithdrawStatus) {
                    mpesaWithdrawStatus.classList.add('hidden');
                }
            }
        }
    }

    function handleDepositAmountChange() {
        const amount = parseFloat(depositAmountInput.value) || 0;
        
        if (amount < CONFIG.PAYMENTS.MIN_DEPOSIT) {
            showNotification(`Minimum deposit is $${CONFIG.PAYMENTS.MIN_DEPOSIT}`, 'error');
            paypalContainer.innerHTML = '';
            return;
        }
        
        if (amount > CONFIG.PAYMENTS.MAX_DEPOSIT) {
            showNotification(`Maximum deposit is $${CONFIG.PAYMENTS.MAX_DEPOSIT}`, 'error');
            paypalContainer.innerHTML = '';
            return;
        }
        
        if (amount >= CONFIG.PAYMENTS.MIN_DEPOSIT && amount <= CONFIG.PAYMENTS.MAX_DEPOSIT) {
            currentDepositAmount = amount;
            initializePayPalButton(amount);
            
            // Update M-Pesa equivalent amount
            if (mpesaTab.classList.contains('active')) {
                const kshAmount = amount * CONFIG.EXCHANGE_RATES.DEPOSIT;
                depositKshAmount.textContent = `Equivalent: Ksh ${kshAmount.toFixed(2)}`;
            }
        }
    }

    function handleWithdrawAmountChange() {
        const amount = parseFloat(withdrawAmountInput.value) || 0;
        
        if (amount < CONFIG.PAYMENTS.MIN_WITHDRAWAL) {
            showNotification(`Minimum withdrawal is $${CONFIG.PAYMENTS.MIN_WITHDRAWAL}`, 'error');
            return;
        }
        
        if (amount > CONFIG.PAYMENTS.MAX_WITHDRAWAL) {
            showNotification(`Maximum withdrawal is $${CONFIG.PAYMENTS.MAX_WITHDRAWAL}`, 'error');
            return;
        }
        
        if (amount > currentUser.balance) {
            showNotification('Insufficient balance for withdrawal', 'error');
            return;
        }
        
        if (amount >= CONFIG.PAYMENTS.MIN_WITHDRAWAL && amount <= CONFIG.PAYMENTS.MAX_WITHDRAWAL) {
            currentWithdrawAmount = amount;
            
            // Update M-Pesa equivalent amount
            if (mpesaTab.classList.contains('active')) {
                const kshAmount = amount * CONFIG.EXCHANGE_RATES.WITHDRAWAL;
                withdrawKshAmount.textContent = `Equivalent: Ksh ${kshAmount.toFixed(2)}`;
            }
        }
    }

    // PayPal Integration
    function initializePayPalButton(amount) {
        // Clear previous PayPal button
        paypalContainer.innerHTML = '';
        
        // Create new PayPal button
        paypal.HostedButtons({
            hostedButtonId: "U7CSKJSFDZLW2",
            onApprove: (data, actions) => {
                // This function is called when the payment is approved
                return actions.order.capture().then(function(details) {
                    // Payment completed successfully
                    handleSuccessfulPayment(amount, 'paypal');
                });
            },
            onError: (err) => {
                // This function is called when an error occurs during payment
                console.error('PayPal payment error:', err);
                showNotification('Payment failed. Please try again.', 'error');
            }
        }).render("#paypal-container");
    }

    async function handleSuccessfulPayment(amount, method) {
        showLoading();
        
        try {
            // Create pending deposit record instead of directly updating balance
            const pendingDeposit = {
                userId: currentUser.id,
                userPhone: currentUser.phone,
                amount: amount,
                method: method,
                date: new Date().toISOString(),
                status: 'pending'
            };
            
            await savePendingDeposit(pendingDeposit);
            
            // Show pending screen instead of success screen
            pendingDepositAmount.textContent = `USD ${amount.toFixed(2)}`;
            pendingDepositMethod.textContent = method === 'paypal' ? 'PayPal' : 'M-Pesa';
            pendingType.textContent = 'deposit';
            pendingType2.textContent = 'deposit';
            showScreen(paymentPendingScreen);
            showNotification(`Deposit of USD ${amount.toFixed(2)} submitted for system verification`, 'info');
        } catch (error) {
            console.error("Payment processing error:", error);
            showNotification('Payment processing failed. Please contact support.', 'error');
            showScreen(dashboardScreen);
        }
    }

    // M-Pesa Deposit Handler
    async function handleMpesaDeposit() {
        const amount = parseFloat(depositAmountInput.value) || 0;
        const phone = mpesaPhoneInput.value.trim();

        // Validation
        if (!phone) {
            showNotification('Please enter your M-Pesa phone number', 'error');
            return;
        }

        if (amount < CONFIG.PAYMENTS.MIN_DEPOSIT) {
            showNotification(`Minimum deposit is $${CONFIG.PAYMENTS.MIN_DEPOSIT}`, 'error');
            return;
        }

        if (amount > CONFIG.PAYMENTS.MAX_DEPOSIT) {
            showNotification(`Maximum deposit is $${CONFIG.PAYMENTS.MAX_DEPOSIT}`, 'error');
            return;
        }

        if (!currentUser) {
            showNotification('Please login first', 'error');
            return;
        }

        showLoading();
        mpesaStatus.classList.remove('hidden');
        mpesaStatusText.textContent = 'Initiating M-Pesa payment...';

        try {
            // For demo purposes - simulate M-Pesa payment
            await simulateMpesaSTKPush(phone, amount);
            
        } catch (error) {
            console.error('M-Pesa deposit error:', error);
            mpesaStatusText.textContent = 'Payment failed. Please try again.';
            showNotification('M-Pesa payment failed', 'error');
            showScreen(depositScreen);
        }
    }

    // Simulate M-Pesa STK Push (for demo - replace with actual M-Pesa API call)
    async function simulateMpesaSTKPush(phone, amount) {
        // Show processing status
        mpesaStatusText.textContent = 'Sending STK Push to your phone...';
        
        // Simulate API call delay
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Simulate successful STK Push
        mpesaStatusText.textContent = ' Check your phone and send the deposit amount to 0717887117.';
        
        // Simulate waiting for user to complete payment
        await new Promise(resolve => setTimeout(resolve, 5000));
        
        // Simulate payment confirmation
        await completeMpesaPayment(amount);
    }

    // Complete M-Pesa payment and create pending deposit
    async function completeMpesaPayment(amount) {
        try {
            mpesaStatusText.textContent = 'Payment successful created! Creating pending deposit...';
            
            // Create pending deposit record instead of directly updating balance
            const pendingDeposit = {
                userId: currentUser.id,
                userPhone: currentUser.phone,
                amount: amount,
                method: 'mpesa',
                date: new Date().toISOString(),
                status: 'pending'
            };
            
            await savePendingDeposit(pendingDeposit);
            
            // Show pending screen
            pendingDepositAmount.textContent = `USD ${amount.toFixed(2)}`;
            pendingDepositMethod.textContent = 'M-Pesa';
            pendingType.textContent = 'deposit';
            pendingType2.textContent = 'deposit';
            showScreen(paymentPendingScreen);
            showNotification(`M-Pesa deposit of USD ${amount.toFixed(2)} submitted for system verification`, 'info');
            
        } catch (error) {
            console.error("M-Pesa payment processing error:", error);
            mpesaStatusText.textContent = 'Payment processing failed. Please contact support.';
            showNotification('M-Pesa payment processing failed', 'error');
            showScreen(depositScreen);
        }
    }

    // Withdrawal Functions
    async function handlePayPalWithdrawal() {
        const amount = parseFloat(withdrawAmountInput.value) || 0;
        const email = paypalEmailInput.value.trim();

        // Validation
        if (!email) {
            showNotification('Please enter your PayPal email address', 'error');
            return;
        }

        if (amount < CONFIG.PAYMENTS.MIN_WITHDRAWAL) {
            showNotification(`Minimum withdrawal is $${CONFIG.PAYMENTS.MIN_WITHDRAWAL}`, 'error');
            return;
        }

        if (amount > CONFIG.PAYMENTS.MAX_WITHDRAWAL) {
            showNotification(`Maximum withdrawal is $${CONFIG.PAYMENTS.MAX_WITHDRAWAL}`, 'error');
            return;
        }

        if (amount > currentUser.balance) {
            showNotification('Insufficient balance for withdrawal', 'error');
            return;
        }

        if (!currentUser) {
            showNotification('Please login first', 'error');
            return;
        }

        showLoading();

        try {
            // Create pending withdrawal record
            const pendingWithdrawal = {
                userId: currentUser.id,
                userPhone: currentUser.phone,
                amount: amount,
                method: 'paypal',
                email: email,
                date: new Date().toISOString(),
                status: 'pending'
            };
            
            await savePendingWithdrawal(pendingWithdrawal);
            
            // Show pending screen
            pendingDepositAmount.textContent = `USD ${amount.toFixed(2)}`;
            pendingDepositMethod.textContent = 'PayPal';
            pendingType.textContent = 'withdrawal';
            pendingType2.textContent = 'withdrawal';
            showScreen(paymentPendingScreen);
            showNotification(`Withdrawal of USD ${amount.toFixed(2)} submitted for system verification`, 'info');
        } catch (error) {
            console.error("PayPal withdrawal error:", error);
            showNotification('Withdrawal request failed. Please try again.', 'error');
            showScreen(depositScreen);
        }
    }

    async function handleMpesaWithdrawal() {
        const amount = parseFloat(withdrawAmountInput.value) || 0;
        const phone = mpesaWithdrawPhoneInput.value.trim();

        // Validation
        if (!phone) {
            showNotification('Please enter your M-Pesa phone number', 'error');
            return;
        }

        if (amount < CONFIG.PAYMENTS.MIN_WITHDRAWAL) {
            showNotification(`Minimum withdrawal is $${CONFIG.PAYMENTS.MIN_WITHDRAWAL}`, 'error');
            return;
        }

        if (amount > CONFIG.PAYMENTS.MAX_WITHDRAWAL) {
            showNotification(`Maximum withdrawal is $${CONFIG.PAYMENTS.MAX_WITHDRAWAL}`, 'error');
            return;
        }

        if (amount > currentUser.balance) {
            showNotification('Insufficient balance for withdrawal', 'error');
            return;
        }

        if (!currentUser) {
            showNotification('Please login first', 'error');
            return;
        }

        showLoading();
        mpesaWithdrawStatus.classList.remove('hidden');
        mpesaWithdrawStatusText.textContent = 'Processing withdrawal request...';

        try {
            // Create pending withdrawal record
            const pendingWithdrawal = {
                userId: currentUser.id,
                userPhone: currentUser.phone,
                amount: amount,
                method: 'mpesa',
                phone: phone,
                date: new Date().toISOString(),
                status: 'pending'
            };
            
            await savePendingWithdrawal(pendingWithdrawal);
            
            // Show pending screen
            pendingDepositAmount.textContent = `USD ${amount.toFixed(2)}`;
            pendingDepositMethod.textContent = 'M-Pesa';
            pendingType.textContent = 'withdrawal';
            pendingType2.textContent = 'withdrawal';
            showScreen(paymentPendingScreen);
            showNotification(`M-Pesa withdrawal of USD ${amount.toFixed(2)} submitted for sys verification`, 'info');
            
        } catch (error) {
            console.error("M-Pesa withdrawal error:", error);
            mpesaWithdrawStatusText.textContent = 'Withdrawal request failed. Please try again.';
            showNotification('M-Pesa withdrawal request failed', 'error');
            showScreen(depositScreen);
        }
    }

    // Admin Functions for Verifying Deposits and Withdrawals
    async function displayPendingDeposits() {
        await loadPendingDeposits();
        pendingDepositsList.innerHTML = '';
        
        if (pendingDeposits.length === 0) {
            pendingDepositsList.innerHTML = '<p class="no-transactions">No pending deposits found</p>';
            return;
        }
        
        pendingDeposits.forEach(deposit => {
            const depositEl = document.createElement('div');
            depositEl.className = 'transaction-admin-item pending-transaction-item';
            
            depositEl.innerHTML = `
                <div class="transaction-info">
                    <div class="transaction-parties"><strong>User:</strong> ${deposit.userPhone}</div>
                    <div class="transaction-date"><strong>Date:</strong> ${new Date(deposit.date).toLocaleString()}</div>
                    <div class="transaction-type"><strong>Method:</strong> ${deposit.method}</div>
                    <div class="transaction-type"><strong>Status:</strong> <span class="status-badge status-pending">Pending</span></div>
                </div>
                <div class="transaction-amounts">
                    <div class="transaction-amount"><strong>Amount:</strong> USD ${deposit.amount.toFixed(2)}</div>
                    <div class="pending-actions">
                        <button class="btn-approve" data-id="${deposit.id}">Approve</button>
                        <button class="btn-reject" data-id="${deposit.id}">Reject</button>
                    </div>
                </div>
            `;
            
            pendingDepositsList.appendChild(depositEl);
        });
        
        // Add event listeners to approve/reject buttons
        setTimeout(() => {
            document.querySelectorAll('.btn-approve').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    approvePendingDeposit(btn.dataset.id);
                });
            });
            
            document.querySelectorAll('.btn-reject').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    rejectPendingDeposit(btn.dataset.id);
                });
            });
        }, 100);
    }

    async function displayPendingWithdrawals() {
        await loadPendingWithdrawals();
        pendingWithdrawalsList.innerHTML = '';
        
        if (pendingWithdrawals.length === 0) {
            pendingWithdrawalsList.innerHTML = '<p class="no-transactions">No pending withdrawals found</p>';
            return;
        }
        
        pendingWithdrawals.forEach(withdrawal => {
            const withdrawalEl = document.createElement('div');
            withdrawalEl.className = 'transaction-admin-item pending-transaction-item';
            
            withdrawalEl.innerHTML = `
                <div class="transaction-info">
                    <div class="transaction-parties"><strong>User:</strong> ${withdrawal.userPhone}</div>
                    <div class="transaction-date"><strong>Date:</strong> ${new Date(withdrawal.date).toLocaleString()}</div>
                    <div class="transaction-type"><strong>Method:</strong> ${withdrawal.method}</div>
                    ${withdrawal.email ? `<div class="transaction-method"><strong>Email:</strong> ${withdrawal.email}</div>` : ''}
                    ${withdrawal.phone ? `<div class="transaction-method"><strong>Phone:</strong> ${withdrawal.phone}</div>` : ''}
                    <div class="transaction-type"><strong>Status:</strong> <span class="status-badge status-pending">Pending</span></div>
                </div>
                <div class="transaction-amounts">
                    <div class="transaction-amount"><strong>Amount:</strong> USD ${withdrawal.amount.toFixed(2)}</div>
                    <div class="pending-actions">
                        <button class="btn-approve" data-id="${withdrawal.id}">Approve</button>
                        <button class="btn-reject" data-id="${withdrawal.id}">Reject</button>
                    </div>
                </div>
            `;
            
            pendingWithdrawalsList.appendChild(withdrawalEl);
        });
        
        // Add event listeners to approve/reject buttons
        setTimeout(() => {
            document.querySelectorAll('.btn-approve').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    approvePendingWithdrawal(btn.dataset.id);
                });
            });
            
            document.querySelectorAll('.btn-reject').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    rejectPendingWithdrawal(btn.dataset.id);
                });
            });
        }, 100);
    }

    async function approvePendingDeposit(depositId) {
        const deposit = pendingDeposits.find(d => d.id === depositId);
        if (!deposit) {
            showNotification('Deposit not found', 'error');
            return;
        }
        
        showLoading();
        
        try {
            // Find the user
            const user = users.find(u => u.id === deposit.userId);
            if (!user) {
                showNotification('User not found', 'error');
                return;
            }
            
            // Update user balance
            user.balance += deposit.amount;
            await saveUser(user);
            
            // Record transaction for the user
            const transaction = {
                from: deposit.method.toUpperCase(),
                to: user.phone,
                amount: deposit.amount,
                fee: 0,
                type: 'deposit',
                method: deposit.method,
                date: new Date().toISOString(),
                userId: user.id,
                status: 'completed'
            };
            
            await saveTransaction(transaction);
            
            // Remove from pending deposits
            await removePendingDeposit(depositId);
            
            // Reload data
            await loadUsers();
            await loadPendingDeposits();
            
            // Update displays
            await displayPendingDeposits();
            
            showNotification(`Deposit of USD ${deposit.amount.toFixed(2)} approved for ${user.phone}`, 'success');
        } catch (error) {
            console.error("Error approving deposit:", error);
            showNotification('Error approving deposit', 'error');
            showScreen(adminPanel);
        }
    }

    async function rejectPendingDeposit(depositId) {
        const deposit = pendingDeposits.find(d => d.id === depositId);
        if (!deposit) {
            showNotification('Deposit not found', 'error');
            return;
        }
        
        showLoading();
        
        try {
            // Record rejected transaction
            const transaction = {
                from: deposit.method.toUpperCase(),
                to: deposit.userPhone,
                amount: deposit.amount,
                fee: 0,
                type: 'deposit',
                method: deposit.method,
                date: new Date().toISOString(),
                userId: deposit.userId,
                status: 'rejected'
            };
            
            await saveTransaction(transaction);
            
            // Remove from pending deposits
            await removePendingDeposit(depositId);
            
            // Reload data
            await loadPendingDeposits();
            
            // Update displays
            await displayPendingDeposits();
            
            showNotification(`Deposit of USD ${deposit.amount.toFixed(2)} rejected for ${deposit.userPhone}`, 'info');
        } catch (error) {
            console.error("Error rejecting deposit:", error);
            showNotification('Error rejecting deposit', 'error');
            showScreen(adminPanel);
        }
    }

    async function approvePendingWithdrawal(withdrawalId) {
        const withdrawal = pendingWithdrawals.find(w => w.id === withdrawalId);
        if (!withdrawal) {
            showNotification('Withdrawal not found', 'error');
            return;
        }
        
        showLoading();
        
        try {
            // Find the user
            const user = users.find(u => u.id === withdrawal.userId);
            if (!user) {
                showNotification('User not found', 'error');
                return;
            }
            
            // Check if user has sufficient balance
            if (user.balance < withdrawal.amount) {
                showNotification('User has insufficient balance for this withdrawal', 'error');
                return;
            }
            
            // Update user balance
            user.balance -= withdrawal.amount;
            await saveUser(user);
            
            // Record transaction for the user
            const transaction = {
                from: user.phone,
                to: withdrawal.method.toUpperCase(),
                amount: withdrawal.amount,
                fee: 0,
                type: 'withdrawal',
                method: withdrawal.method,
                date: new Date().toISOString(),
                userId: user.id,
                status: 'completed'
            };
            
            await saveTransaction(transaction);
            
            // Remove from pending withdrawals
            await removePendingWithdrawal(withdrawalId);
            
            // Reload data
            await loadUsers();
            await loadPendingWithdrawals();
            
            // Update displays
            await displayPendingWithdrawals();
            
            showNotification(`Withdrawal of USD ${withdrawal.amount.toFixed(2)} approved for ${user.phone}`, 'success');
        } catch (error) {
            console.error("Error approving withdrawal:", error);
            showNotification('Error approving withdrawal', 'error');
            showScreen(adminPanel);
        }
    }

    async function rejectPendingWithdrawal(withdrawalId) {
        const withdrawal = pendingWithdrawals.find(w => w.id === withdrawalId);
        if (!withdrawal) {
            showNotification('Withdrawal not found', 'error');
            return;
        }
        
        showLoading();
        
        try {
            // Record rejected transaction
            const transaction = {
                from: withdrawal.userPhone,
                to: withdrawal.method.toUpperCase(),
                amount: withdrawal.amount,
                fee: 0,
                type: 'withdrawal',
                method: withdrawal.method,
                date: new Date().toISOString(),
                userId: withdrawal.userId,
                status: 'rejected'
            };
            
            await saveTransaction(transaction);
            
            // Remove from pending withdrawals
            await removePendingWithdrawal(withdrawalId);
            
            // Reload data
            await loadPendingWithdrawals();
            
            // Update displays
            await displayPendingWithdrawals();
            
            showNotification(`Withdrawal of USD ${withdrawal.amount.toFixed(2)} rejected for ${withdrawal.userPhone}`, 'info');
        } catch (error) {
            console.error("Error rejecting withdrawal:", error);
            showNotification('Error rejecting withdrawal', 'error');
            showScreen(adminPanel);
        }
    }

    // Updated Admin Panel Functions
    async function showAdminPanel() {
        if (!currentUser || !currentUser.isAdmin) {
            showNotification('Access denied', 'error');
            return;
        }
        
        showScreen(adminPanel);
        
        // Hide all sections by default
        usersSection.classList.add('hidden');
        transactionsSection.classList.add('hidden');
        pendingSection.classList.add('hidden');
        pendingWithdrawalsSection.classList.add('hidden');
    }

    async function displayAllUsers() {
        await loadUsers();
        usersList.innerHTML = '';
        
        if (users.length === 0) {
            usersList.innerHTML = '<p class="no-users">No users found</p>';
            return;
        }
        
        users.forEach(user => {
            // Skip showing the admin user in the list to avoid self-management
            if (user.isAdmin && user.phone === currentUser.phone) return;
            
            const userEl = document.createElement('div');
            userEl.className = 'user-item';
            
            let statusClass = 'status-active';
            let statusText = 'Active';
            
            if (user.isBlocked) {
                statusClass = 'status-blocked';
                statusText = 'Blocked';
            } else if (user.isSuspended) {
                statusClass = 'status-suspended';
                statusText = 'Suspended';
            }
            
            userEl.innerHTML = `
                <div class="user-info">
                    <div class="user-phone"><strong>${user.phone}</strong></div>
                    <div class="user-balance">Balance: USD ${user.balance.toFixed(2)}</div>
                    <div class="user-registered">Registered: ${new Date(user.dateCreated).toLocaleDateString()}</div>
                </div>
                <div class="user-controls">
                    <span class="status-badge ${statusClass}">${statusText}</span>
                    <div class="user-actions">
                        <button class="action-btn suspend" data-phone="${user.phone}">${user.isSuspended ? 'Activate' : 'Suspend'}</button>
                        <button class="action-btn block" data-phone="${user.phone}">${user.isBlocked ? 'Unblock' : 'Block'}</button>
                        <button class="action-btn deduct" data-phone="${user.phone}">Deduct Funds</button>
                        <button class="action-btn recover" data-phone="${user.phone}">Recover Funds</button>
                    </div>
                </div>
            `;
            
            usersList.appendChild(userEl);
        });
        
        // Add event listeners to action buttons
        setTimeout(() => {
            document.querySelectorAll('.action-btn.suspend').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleSuspendUser(btn.dataset.phone);
                });
            });
            
            document.querySelectorAll('.action-btn.block').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleBlockUser(btn.dataset.phone);
                });
            });
            
            document.querySelectorAll('.action-btn.deduct').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openDeductionModal(btn.dataset.phone);
                });
            });
            
            document.querySelectorAll('.action-btn.recover').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleRecoverFunds(btn.dataset.phone);
                });
            });
        }, 100);
    }

    function filterUsers() {
        const searchTerm = userSearch.value.toLowerCase();
        const userItems = document.querySelectorAll('.user-item');
        
        userItems.forEach(item => {
            const phone = item.querySelector('.user-phone').textContent.toLowerCase();
            if (phone.includes(searchTerm)) {
                item.style.display = 'flex';
            } else {
                item.style.display = 'none';
            }
        });
    }

    async function displayAllTransactions() {
        await loadTransactions();
        adminTransactionsList.innerHTML = '';
        
        if (transactions.length === 0) {
            adminTransactionsList.innerHTML = '<p class="no-transactions">No transactions found</p>';
            return;
        }
        
        // Display ALL transactions without filtering by user ID
        transactions.forEach(transaction => {
            const transactionEl = document.createElement('div');
            transactionEl.className = 'transaction-admin-item';
            
            // Get status badge
            let statusBadge = '';
            if (transaction.status) {
                const statusClass = transaction.status === 'completed' ? 'status-completed' : 
                                  transaction.status === 'rejected' ? 'status-rejected' : 
                                  transaction.status === 'pending' ? 'status-pending' : 'status-pending';
                statusBadge = `<span class="status-badge ${statusClass}">${transaction.status}</span>`;
            }
            
            transactionEl.innerHTML = `
                <div class="transaction-info">
                    <div class="transaction-parties"><strong>From:</strong> ${transaction.from} <strong>‚Üí To:</strong> ${transaction.to}</div>
                    <div class="transaction-date"><strong>Date:</strong> ${new Date(transaction.date).toLocaleString()}</div>
                    <div class="transaction-type"><strong>Type:</strong> ${transaction.type} ${statusBadge}</div>
                    ${transaction.transactionHash ? `<div class="transaction-hash"><strong>Hash:</strong> ${transaction.transactionHash}</div>` : ''}
                    ${transaction.blockNumber ? `<div class="block-number"><strong>Block:</strong> ${transaction.blockNumber}</div>` : ''}
                    ${transaction.method ? `<div class="transaction-method"><strong>Method:</strong> ${transaction.method}</div>` : ''}
                    ${transaction.reason ? `<div class="transaction-reason"><strong>Reason:</strong> ${transaction.reason}</div>` : ''}
                </div>
                <div class="transaction-amounts">
                    <div class="transaction-amount"><strong>Amount:</strong> USD ${transaction.amount.toFixed(2)}</div>
                    ${transaction.fee > 0 ? `<div class="transaction-fee"><strong>Fee:</strong> USD ${transaction.fee.toFixed(2)}</div>` : ''}
                </div>
            `;
            
            adminTransactionsList.appendChild(transactionEl);
        });
    }

    function filterTransactions() {
        const searchTerm = transactionSearch.value.toLowerCase();
        const transactionItems = document.querySelectorAll('.transaction-admin-item');
        
        transactionItems.forEach(item => {
            const from = item.querySelector('.transaction-parties').textContent.toLowerCase();
            const type = item.querySelector('.transaction-type').textContent.toLowerCase();
            const method = item.querySelector('.transaction-method') ? 
                item.querySelector('.transaction-method').textContent.toLowerCase() : '';
            
            if (from.includes(searchTerm) || type.includes(searchTerm) || method.includes(searchTerm)) {
                item.style.display = 'flex';
            } else {
                item.style.display = 'none';
            }
        });
    }

    // Deduction Modal Functions
    function openDeductionModal(phone) {
        const user = users.find(u => u.phone === phone);
        if (!user) {
            showNotification('User not found', 'error');
            return;
        }
        
        currentDeductionUser = user;
        
        // Populate user info
        deductionUserInfo.innerHTML = `
            <p><strong>User:</strong> ${user.phone}</p>
            <p><strong>Current Balance:</strong> USD ${user.balance.toFixed(2)}</p>
            <p><strong>Status:</strong> ${user.isBlocked ? 'Blocked' : user.isSuspended ? 'Suspended' : 'Active'}</p>
        `;
        
        // Reset form
        deductionAmountInput.value = '';
        deductionReasonInput.value = '';
        
        // Show modal
        deductionModal.classList.remove('hidden');
    }

    function closeDeductionModalFunc() {
        deductionModal.classList.add('hidden');
        currentDeductionUser = null;
    }

    async function handleDeduction() {
        const amount = parseFloat(deductionAmountInput.value) || 0;
        const reason = deductionReasonInput.value.trim();
        
        if (!amount || amount <= 0) {
            showNotification('Please enter a valid amount', 'error');
            return;
        }
        
        if (!reason) {
            showNotification('Please enter a reason for deduction', 'error');
            return;
        }
        
        if (amount > currentDeductionUser.balance) {
            showNotification('Deduction amount exceeds user balance', 'error');
            return;
        }
        
        showLoading();
        
        try {
            // Update user balance
            currentDeductionUser.balance -= amount;
            
            // Add to admin account
            const adminUser = users.find(u => u.isAdmin);
            if (adminUser) {
                adminUser.balance += amount;
                await saveUser(adminUser);
            }
            
            // Save updated user
            await saveUser(currentDeductionUser);
            
            // Record transaction for the user who was deducted
            const userTransaction = {
                from: currentDeductionUser.phone,
                to: 'ADMIN',
                amount: amount,
                fee: 0,
                type: 'deduction',
                reason: reason,
                date: new Date().toISOString(),
                userId: currentDeductionUser.id,
                status: 'completed'
            };
            
            await saveTransaction(userTransaction);
            
            // Record transaction for the admin who received the deduction
            const adminTransaction = {
                from: currentDeductionUser.phone,
                to: 'ADMIN',
                amount: amount,
                fee: 0,
                type: 'deduction_received',
                reason: reason,
                date: new Date().toISOString(),
                userId: adminUser.id, // This is the key fix - saving with admin's ID
                status: 'completed'
            };
            
            await saveTransaction(adminTransaction);
            
            // Reload data
            await loadUsers();
            await loadTransactions();
            
            // Update displays
            await displayAllUsers();
            await displayAllTransactions();
            
            // Close modal
            closeDeductionModalFunc();
            
            showNotification(`Deducted USD ${amount.toFixed(2)} from ${currentDeductionUser.phone}`, 'success');
        } catch (error) {
            console.error("Deduction error:", error);
            showNotification('Deduction failed. Please try again.', 'error');
            showScreen(adminPanel);
        }
    }

    async function handleSuspendUser(phone) {
        const user = users.find(u => u.phone === phone);
        if (user) {
            user.isSuspended = !user.isSuspended;
            user.isBlocked = false; // Can't be both suspended and blocked
            await saveUser(user);
            await displayAllUsers();
            showNotification(`User ${user.isSuspended ? 'suspended' : 'activated'}`, 'info');
        }
    }

    async function handleBlockUser(phone) {
        const user = users.find(u => u.phone === phone);
        if (user) {
            user.isBlocked = !user.isBlocked;
            user.isSuspended = false; // Can't be both suspended and blocked
            await saveUser(user);
            await displayAllUsers();
            showNotification(`User ${user.isBlocked ? 'blocked' : 'activated'}`, 'info');
        }
    }

    async function handleRecoverFunds(phone) {
        const user = users.find(u => u.phone === phone);
        if (user && user.balance > 0) {
            const amount = user.balance;
            
            // Add to admin account
            const adminUser = users.find(u => u.isAdmin);
            if (adminUser) {
                adminUser.balance += amount;
                await saveUser(adminUser);
            }
            
            // Record transaction for user
            const userTransaction = {
                from: user.phone,
                to: 'ADMIN',
                amount: amount,
                fee: 0,
                type: 'recovery',
                date: new Date().toISOString(),
                userId: user.id
            };
            
            await saveTransaction(userTransaction);
            
            // Record transaction for admin
            const adminTransaction = {
                from: user.phone,
                to: 'ADMIN',
                amount: amount,
                fee: 0,
                type: 'recovery_received',
                date: new Date().toISOString(),
                userId: adminUser.id
            };
            
            await saveTransaction(adminTransaction);
            
            // Reset user balance
            user.balance = 0;
            await saveUser(user);
            
            await displayAllUsers();
            await displayAllTransactions();
            showNotification(`Recovered USD ${amount.toFixed(2)} from ${user.phone}`, 'success');
        } else {
            showNotification('No funds to recover', 'info');
        }
    }

    // Make the app global
    window.app = {
        currentUser: null,
        updateDashboard: updateDashboard,
        showNotification: showNotification,
        
        // This will be set when user logs in
        setCurrentUser: function(user) {
            this.currentUser = user;
            currentUser = user; // Also set the local variable
        }
    };

    // Initialize the app
    document.addEventListener('DOMContentLoaded', async () => {
        showScreen(authScreen);
        
        // Load transaction counter
        await loadTransactionCounter();
        
        // Initialize admin account if not exists
        try {
            await loadUsers();
            const adminExists = users.find(u => u.phone === '0700000000');
            
            if (!adminExists) {
                const adminAccount = {
                    phone: '0700000000',
                    pin: '0000',
                    balance: 0,
                    isAdmin: true,
                    isSuspended: false,
                    isBlocked: false,
                    dateCreated: new Date().toISOString()
                };
                
                await saveUser(adminAccount);
                users.push(adminAccount);
                console.log('Admin account created');
            } else {
                console.log('Admin account already exists');
            }
        } catch (error) {
            console.error("Error initializing admin account:", error);
        }
    });
</script>



</body>
</html>
